// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const AddRevokedCertificate = `-- name: AddRevokedCertificate :exec
INSERT INTO fabric_revoked_certificates (
    fabric_organization_id,
    serial_number,
    revocation_time,
    reason,
    issuer_certificate_id
) VALUES (?, ?, ?, ?, ?)
`

type AddRevokedCertificateParams struct {
	FabricOrganizationID int64         `json:"fabricOrganizationId"`
	SerialNumber         string        `json:"serialNumber"`
	RevocationTime       time.Time     `json:"revocationTime"`
	Reason               int64         `json:"reason"`
	IssuerCertificateID  sql.NullInt64 `json:"issuerCertificateId"`
}

func (q *Queries) AddRevokedCertificate(ctx context.Context, arg *AddRevokedCertificateParams) error {
	_, err := q.db.ExecContext(ctx, AddRevokedCertificate,
		arg.FabricOrganizationID,
		arg.SerialNumber,
		arg.RevocationTime,
		arg.Reason,
		arg.IssuerCertificateID,
	)
	return err
}

const CheckNetworkNodeExists = `-- name: CheckNetworkNodeExists :one
SELECT EXISTS(SELECT 1 FROM network_nodes WHERE network_id = ? AND node_id = ?)
`

type CheckNetworkNodeExistsParams struct {
	NetworkID int64 `json:"networkId"`
	NodeID    int64 `json:"nodeId"`
}

func (q *Queries) CheckNetworkNodeExists(ctx context.Context, arg *CheckNetworkNodeExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, CheckNetworkNodeExists, arg.NetworkID, arg.NodeID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const CountAuditLogs = `-- name: CountAuditLogs :one
SELECT COUNT(*) FROM audit_logs
WHERE (? IS NULL OR timestamp >= ?)
  AND (? IS NULL OR timestamp <= ?)
  AND (? = '' OR event_type = ?)
  AND (? = '' OR user_identity = ?)
`

type CountAuditLogsParams struct {
	Column1      interface{} `json:"column1"`
	Timestamp    time.Time   `json:"timestamp"`
	Column3      interface{} `json:"column3"`
	Timestamp_2  time.Time   `json:"timestamp2"`
	Column5      interface{} `json:"column5"`
	EventType    string      `json:"eventType"`
	Column7      interface{} `json:"column7"`
	UserIdentity int64       `json:"userIdentity"`
}

func (q *Queries) CountAuditLogs(ctx context.Context, arg *CountAuditLogsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountAuditLogs,
		arg.Column1,
		arg.Timestamp,
		arg.Column3,
		arg.Timestamp_2,
		arg.Column5,
		arg.EventType,
		arg.Column7,
		arg.UserIdentity,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountBackupsBySchedule = `-- name: CountBackupsBySchedule :one
SELECT COUNT(*) FROM backups
WHERE schedule_id = ?
`

func (q *Queries) CountBackupsBySchedule(ctx context.Context, scheduleID sql.NullInt64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountBackupsBySchedule, scheduleID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountBackupsByTarget = `-- name: CountBackupsByTarget :one
SELECT COUNT(*) FROM backups
WHERE target_id = ?
`

func (q *Queries) CountBackupsByTarget(ctx context.Context, targetID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountBackupsByTarget, targetID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountNetworks = `-- name: CountNetworks :one
SELECT COUNT(*) FROM networks
`

func (q *Queries) CountNetworks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountNetworks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountNodeEvents = `-- name: CountNodeEvents :one
SELECT COUNT(*) FROM node_events
WHERE node_id = ?
`

func (q *Queries) CountNodeEvents(ctx context.Context, nodeID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountNodeEvents, nodeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountNodes = `-- name: CountNodes :one
SELECT COUNT(*) FROM nodes
`

func (q *Queries) CountNodes(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountNodes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountNodesByPlatform = `-- name: CountNodesByPlatform :one
SELECT COUNT(*) FROM nodes
WHERE platform = ?
`

func (q *Queries) CountNodesByPlatform(ctx context.Context, platform string) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountNodesByPlatform, platform)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_logs (
    timestamp,
    event_source,
    user_identity,
    source_ip,
    event_type,
    event_outcome,
    affected_resource,
    request_id,
    severity,
    details
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, timestamp, event_source, user_identity, source_ip, event_type, event_outcome, affected_resource, request_id, severity, details, created_at, updated_at
`

type CreateAuditLogParams struct {
	Timestamp        time.Time      `json:"timestamp"`
	EventSource      string         `json:"eventSource"`
	UserIdentity     int64          `json:"userIdentity"`
	SourceIp         sql.NullString `json:"sourceIp"`
	EventType        string         `json:"eventType"`
	EventOutcome     string         `json:"eventOutcome"`
	AffectedResource sql.NullString `json:"affectedResource"`
	RequestID        sql.NullString `json:"requestId"`
	Severity         sql.NullString `json:"severity"`
	Details          sql.NullString `json:"details"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg *CreateAuditLogParams) (*AuditLog, error) {
	row := q.db.QueryRowContext(ctx, CreateAuditLog,
		arg.Timestamp,
		arg.EventSource,
		arg.UserIdentity,
		arg.SourceIp,
		arg.EventType,
		arg.EventOutcome,
		arg.AffectedResource,
		arg.RequestID,
		arg.Severity,
		arg.Details,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.Timestamp,
		&i.EventSource,
		&i.UserIdentity,
		&i.SourceIp,
		&i.EventType,
		&i.EventOutcome,
		&i.AffectedResource,
		&i.RequestID,
		&i.Severity,
		&i.Details,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CreateBackup = `-- name: CreateBackup :one
INSERT INTO backups (
    schedule_id,
    target_id,
    status,
    started_at,
    created_at
) VALUES (
    ?,
    ?,
    ?,
    ?,
    CURRENT_TIMESTAMP
) RETURNING id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent
`

type CreateBackupParams struct {
	ScheduleID sql.NullInt64 `json:"scheduleId"`
	TargetID   int64         `json:"targetId"`
	Status     string        `json:"status"`
	StartedAt  time.Time     `json:"startedAt"`
}

func (q *Queries) CreateBackup(ctx context.Context, arg *CreateBackupParams) (*Backup, error) {
	row := q.db.QueryRowContext(ctx, CreateBackup,
		arg.ScheduleID,
		arg.TargetID,
		arg.Status,
		arg.StartedAt,
	)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.ScheduleID,
		&i.TargetID,
		&i.Status,
		&i.SizeBytes,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.NotificationSent,
	)
	return &i, err
}

const CreateBackupSchedule = `-- name: CreateBackupSchedule :one
INSERT INTO backup_schedules (
    name,
    description,
    cron_expression,
    target_id,
    retention_days,
    enabled,
    created_at,
    updated_at
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP
) RETURNING id, name, description, cron_expression, target_id, retention_days, enabled, created_at, updated_at, last_run_at, next_run_at
`

type CreateBackupScheduleParams struct {
	Name           string         `json:"name"`
	Description    sql.NullString `json:"description"`
	CronExpression string         `json:"cronExpression"`
	TargetID       int64          `json:"targetId"`
	RetentionDays  int64          `json:"retentionDays"`
	Enabled        bool           `json:"enabled"`
}

func (q *Queries) CreateBackupSchedule(ctx context.Context, arg *CreateBackupScheduleParams) (*BackupSchedule, error) {
	row := q.db.QueryRowContext(ctx, CreateBackupSchedule,
		arg.Name,
		arg.Description,
		arg.CronExpression,
		arg.TargetID,
		arg.RetentionDays,
		arg.Enabled,
	)
	var i BackupSchedule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CronExpression,
		&i.TargetID,
		&i.RetentionDays,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastRunAt,
		&i.NextRunAt,
	)
	return &i, err
}

const CreateBackupTarget = `-- name: CreateBackupTarget :one
INSERT INTO backup_targets (
    name,
    type,
    bucket_name,
    region,
    endpoint,
    bucket_path,
    access_key_id,
    secret_key,
    s3_path_style,
    restic_password,
    created_at,
    updated_at
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP
) RETURNING id, name, bucket_name, region, endpoint, bucket_path, access_key_id, secret_key, s3_path_style, restic_password, type, created_at, updated_at
`

type CreateBackupTargetParams struct {
	Name           string         `json:"name"`
	Type           string         `json:"type"`
	BucketName     sql.NullString `json:"bucketName"`
	Region         sql.NullString `json:"region"`
	Endpoint       sql.NullString `json:"endpoint"`
	BucketPath     sql.NullString `json:"bucketPath"`
	AccessKeyID    sql.NullString `json:"accessKeyId"`
	SecretKey      sql.NullString `json:"secretKey"`
	S3PathStyle    sql.NullBool   `json:"s3PathStyle"`
	ResticPassword sql.NullString `json:"resticPassword"`
}

func (q *Queries) CreateBackupTarget(ctx context.Context, arg *CreateBackupTargetParams) (*BackupTarget, error) {
	row := q.db.QueryRowContext(ctx, CreateBackupTarget,
		arg.Name,
		arg.Type,
		arg.BucketName,
		arg.Region,
		arg.Endpoint,
		arg.BucketPath,
		arg.AccessKeyID,
		arg.SecretKey,
		arg.S3PathStyle,
		arg.ResticPassword,
	)
	var i BackupTarget
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BucketName,
		&i.Region,
		&i.Endpoint,
		&i.BucketPath,
		&i.AccessKeyID,
		&i.SecretKey,
		&i.S3PathStyle,
		&i.ResticPassword,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CreateFabricOrganization = `-- name: CreateFabricOrganization :one
INSERT INTO fabric_organizations (
    msp_id, description, config, ca_config, sign_key_id,
    tls_root_key_id, provider_id, created_by,
    admin_tls_key_id, admin_sign_key_id, client_sign_key_id
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, msp_id, description, config, ca_config, sign_key_id, tls_root_key_id, admin_tls_key_id, admin_sign_key_id, client_sign_key_id, provider_id, created_at, created_by, updated_at, crl_key_id, crl_last_update
`

type CreateFabricOrganizationParams struct {
	MspID           string         `json:"mspId"`
	Description     sql.NullString `json:"description"`
	Config          sql.NullString `json:"config"`
	CaConfig        sql.NullString `json:"caConfig"`
	SignKeyID       sql.NullInt64  `json:"signKeyId"`
	TlsRootKeyID    sql.NullInt64  `json:"tlsRootKeyId"`
	ProviderID      sql.NullInt64  `json:"providerId"`
	CreatedBy       sql.NullInt64  `json:"createdBy"`
	AdminTlsKeyID   sql.NullInt64  `json:"adminTlsKeyId"`
	AdminSignKeyID  sql.NullInt64  `json:"adminSignKeyId"`
	ClientSignKeyID sql.NullInt64  `json:"clientSignKeyId"`
}

func (q *Queries) CreateFabricOrganization(ctx context.Context, arg *CreateFabricOrganizationParams) (*FabricOrganization, error) {
	row := q.db.QueryRowContext(ctx, CreateFabricOrganization,
		arg.MspID,
		arg.Description,
		arg.Config,
		arg.CaConfig,
		arg.SignKeyID,
		arg.TlsRootKeyID,
		arg.ProviderID,
		arg.CreatedBy,
		arg.AdminTlsKeyID,
		arg.AdminSignKeyID,
		arg.ClientSignKeyID,
	)
	var i FabricOrganization
	err := row.Scan(
		&i.ID,
		&i.MspID,
		&i.Description,
		&i.Config,
		&i.CaConfig,
		&i.SignKeyID,
		&i.TlsRootKeyID,
		&i.AdminTlsKeyID,
		&i.AdminSignKeyID,
		&i.ClientSignKeyID,
		&i.ProviderID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.CrlKeyID,
		&i.CrlLastUpdate,
	)
	return &i, err
}

const CreateKey = `-- name: CreateKey :one
INSERT INTO keys (
    name, description, algorithm, key_size, curve, format,
    public_key, private_key, certificate, status, expires_at, sha256_fingerprint,
    sha1_fingerprint, provider_id, user_id, is_ca, ethereum_address
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, description, algorithm, key_size, curve, format, public_key, private_key, certificate, status, created_at, updated_at, expires_at, last_rotated_at, signing_key_id, sha256_fingerprint, sha1_fingerprint, provider_id, user_id, is_ca, ethereum_address
`

type CreateKeyParams struct {
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Algorithm         string         `json:"algorithm"`
	KeySize           sql.NullInt64  `json:"keySize"`
	Curve             sql.NullString `json:"curve"`
	Format            string         `json:"format"`
	PublicKey         string         `json:"publicKey"`
	PrivateKey        string         `json:"privateKey"`
	Certificate       sql.NullString `json:"certificate"`
	Status            string         `json:"status"`
	ExpiresAt         sql.NullTime   `json:"expiresAt"`
	Sha256Fingerprint string         `json:"sha256Fingerprint"`
	Sha1Fingerprint   string         `json:"sha1Fingerprint"`
	ProviderID        int64          `json:"providerId"`
	UserID            int64          `json:"userId"`
	IsCa              int64          `json:"isCa"`
	EthereumAddress   sql.NullString `json:"ethereumAddress"`
}

func (q *Queries) CreateKey(ctx context.Context, arg *CreateKeyParams) (*Key, error) {
	row := q.db.QueryRowContext(ctx, CreateKey,
		arg.Name,
		arg.Description,
		arg.Algorithm,
		arg.KeySize,
		arg.Curve,
		arg.Format,
		arg.PublicKey,
		arg.PrivateKey,
		arg.Certificate,
		arg.Status,
		arg.ExpiresAt,
		arg.Sha256Fingerprint,
		arg.Sha1Fingerprint,
		arg.ProviderID,
		arg.UserID,
		arg.IsCa,
		arg.EthereumAddress,
	)
	var i Key
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Algorithm,
		&i.KeySize,
		&i.Curve,
		&i.Format,
		&i.PublicKey,
		&i.PrivateKey,
		&i.Certificate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.LastRotatedAt,
		&i.SigningKeyID,
		&i.Sha256Fingerprint,
		&i.Sha1Fingerprint,
		&i.ProviderID,
		&i.UserID,
		&i.IsCa,
		&i.EthereumAddress,
	)
	return &i, err
}

const CreateKeyProvider = `-- name: CreateKeyProvider :one
INSERT INTO key_providers (name, type, is_default, config)
VALUES (?, ?, ?, ?)
RETURNING id, name, type, is_default, config, created_at, updated_at
`

type CreateKeyProviderParams struct {
	Name      string `json:"name"`
	Type      string `json:"type"`
	IsDefault int64  `json:"isDefault"`
	Config    string `json:"config"`
}

func (q *Queries) CreateKeyProvider(ctx context.Context, arg *CreateKeyProviderParams) (*KeyProvider, error) {
	row := q.db.QueryRowContext(ctx, CreateKeyProvider,
		arg.Name,
		arg.Type,
		arg.IsDefault,
		arg.Config,
	)
	var i KeyProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.IsDefault,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CreateNetwork = `-- name: CreateNetwork :one
INSERT INTO networks (
    name, platform, status, description, config,
    deployment_config, exposed_ports, domain, created_by, network_id
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, name, network_id, platform, status, description, config, deployment_config, exposed_ports, domain, created_at, created_by, updated_at, genesis_block_b64, current_config_block_b64
`

type CreateNetworkParams struct {
	Name             string         `json:"name"`
	Platform         string         `json:"platform"`
	Status           string         `json:"status"`
	Description      sql.NullString `json:"description"`
	Config           sql.NullString `json:"config"`
	DeploymentConfig sql.NullString `json:"deploymentConfig"`
	ExposedPorts     sql.NullString `json:"exposedPorts"`
	Domain           sql.NullString `json:"domain"`
	CreatedBy        sql.NullInt64  `json:"createdBy"`
	NetworkID        sql.NullString `json:"networkId"`
}

func (q *Queries) CreateNetwork(ctx context.Context, arg *CreateNetworkParams) (*Network, error) {
	row := q.db.QueryRowContext(ctx, CreateNetwork,
		arg.Name,
		arg.Platform,
		arg.Status,
		arg.Description,
		arg.Config,
		arg.DeploymentConfig,
		arg.ExposedPorts,
		arg.Domain,
		arg.CreatedBy,
		arg.NetworkID,
	)
	var i Network
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NetworkID,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.Config,
		&i.DeploymentConfig,
		&i.ExposedPorts,
		&i.Domain,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.GenesisBlockB64,
		&i.CurrentConfigBlockB64,
	)
	return &i, err
}

const CreateNetworkFull = `-- name: CreateNetworkFull :one
INSERT INTO networks (
    name, platform, status, description, config,
    deployment_config, exposed_ports, domain, created_by, network_id, genesis_block_b64
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, name, network_id, platform, status, description, config, deployment_config, exposed_ports, domain, created_at, created_by, updated_at, genesis_block_b64, current_config_block_b64
`

type CreateNetworkFullParams struct {
	Name             string         `json:"name"`
	Platform         string         `json:"platform"`
	Status           string         `json:"status"`
	Description      sql.NullString `json:"description"`
	Config           sql.NullString `json:"config"`
	DeploymentConfig sql.NullString `json:"deploymentConfig"`
	ExposedPorts     sql.NullString `json:"exposedPorts"`
	Domain           sql.NullString `json:"domain"`
	CreatedBy        sql.NullInt64  `json:"createdBy"`
	NetworkID        sql.NullString `json:"networkId"`
	GenesisBlockB64  sql.NullString `json:"genesisBlockB64"`
}

func (q *Queries) CreateNetworkFull(ctx context.Context, arg *CreateNetworkFullParams) (*Network, error) {
	row := q.db.QueryRowContext(ctx, CreateNetworkFull,
		arg.Name,
		arg.Platform,
		arg.Status,
		arg.Description,
		arg.Config,
		arg.DeploymentConfig,
		arg.ExposedPorts,
		arg.Domain,
		arg.CreatedBy,
		arg.NetworkID,
		arg.GenesisBlockB64,
	)
	var i Network
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NetworkID,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.Config,
		&i.DeploymentConfig,
		&i.ExposedPorts,
		&i.Domain,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.GenesisBlockB64,
		&i.CurrentConfigBlockB64,
	)
	return &i, err
}

const CreateNetworkNode = `-- name: CreateNetworkNode :one
INSERT INTO network_nodes (
    network_id,
    node_id,
    status,
    role
) VALUES (
    ?, ?, ?, ?
) RETURNING id, network_id, node_id, role, status, config, created_at, updated_at
`

type CreateNetworkNodeParams struct {
	NetworkID int64  `json:"networkId"`
	NodeID    int64  `json:"nodeId"`
	Status    string `json:"status"`
	Role      string `json:"role"`
}

// Add queries for CRUD operations
func (q *Queries) CreateNetworkNode(ctx context.Context, arg *CreateNetworkNodeParams) (*NetworkNode, error) {
	row := q.db.QueryRowContext(ctx, CreateNetworkNode,
		arg.NetworkID,
		arg.NodeID,
		arg.Status,
		arg.Role,
	)
	var i NetworkNode
	err := row.Scan(
		&i.ID,
		&i.NetworkID,
		&i.NodeID,
		&i.Role,
		&i.Status,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CreateNode = `-- name: CreateNode :one
INSERT INTO nodes (
    name,
    slug,
    platform,
    status,
    description,
    network_id,
    config,
    resources,
    endpoint,
    public_endpoint,
    p2p_address,
    created_by,
    fabric_organization_id,
    node_type,
    node_config,
    created_at,
    updated_at
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP
) RETURNING id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config, error_message
`

type CreateNodeParams struct {
	Name                 string         `json:"name"`
	Slug                 string         `json:"slug"`
	Platform             string         `json:"platform"`
	Status               string         `json:"status"`
	Description          sql.NullString `json:"description"`
	NetworkID            sql.NullInt64  `json:"networkId"`
	Config               sql.NullString `json:"config"`
	Resources            sql.NullString `json:"resources"`
	Endpoint             sql.NullString `json:"endpoint"`
	PublicEndpoint       sql.NullString `json:"publicEndpoint"`
	P2pAddress           sql.NullString `json:"p2pAddress"`
	CreatedBy            sql.NullInt64  `json:"createdBy"`
	FabricOrganizationID sql.NullInt64  `json:"fabricOrganizationId"`
	NodeType             sql.NullString `json:"nodeType"`
	NodeConfig           sql.NullString `json:"nodeConfig"`
}

func (q *Queries) CreateNode(ctx context.Context, arg *CreateNodeParams) (*Node, error) {
	row := q.db.QueryRowContext(ctx, CreateNode,
		arg.Name,
		arg.Slug,
		arg.Platform,
		arg.Status,
		arg.Description,
		arg.NetworkID,
		arg.Config,
		arg.Resources,
		arg.Endpoint,
		arg.PublicEndpoint,
		arg.P2pAddress,
		arg.CreatedBy,
		arg.FabricOrganizationID,
		arg.NodeType,
		arg.NodeConfig,
	)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.NetworkID,
		&i.Config,
		&i.Resources,
		&i.Endpoint,
		&i.PublicEndpoint,
		&i.P2pAddress,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.FabricOrganizationID,
		&i.NodeType,
		&i.NodeConfig,
		&i.DeploymentConfig,
		&i.ErrorMessage,
	)
	return &i, err
}

const CreateNodeEvent = `-- name: CreateNodeEvent :one
INSERT INTO node_events (
    node_id,
    event_type,
    description,
    data,
    status
) VALUES (
    ?, ?, ?, ?, ?
)
RETURNING id, node_id, event_type, description, data, status, created_at
`

type CreateNodeEventParams struct {
	NodeID      int64          `json:"nodeId"`
	EventType   string         `json:"eventType"`
	Description string         `json:"description"`
	Data        sql.NullString `json:"data"`
	Status      string         `json:"status"`
}

func (q *Queries) CreateNodeEvent(ctx context.Context, arg *CreateNodeEventParams) (*NodeEvent, error) {
	row := q.db.QueryRowContext(ctx, CreateNodeEvent,
		arg.NodeID,
		arg.EventType,
		arg.Description,
		arg.Data,
		arg.Status,
	)
	var i NodeEvent
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.EventType,
		&i.Description,
		&i.Data,
		&i.Status,
		&i.CreatedAt,
	)
	return &i, err
}

const CreateNotificationProvider = `-- name: CreateNotificationProvider :one
INSERT INTO notification_providers (
    type,
    name,
    config,
    is_default,
    notify_node_downtime,
    notify_backup_success,
    notify_backup_failure,
    notify_s3_connection_issue,
    created_at,
    updated_at
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP
) RETURNING id, name, type, config, is_default, is_enabled, created_at, updated_at, notify_node_downtime, notify_backup_success, notify_backup_failure, notify_s3_connection_issue, last_test_at, last_test_status, last_test_message
`

type CreateNotificationProviderParams struct {
	Type                    string `json:"type"`
	Name                    string `json:"name"`
	Config                  string `json:"config"`
	IsDefault               bool   `json:"isDefault"`
	NotifyNodeDowntime      bool   `json:"notifyNodeDowntime"`
	NotifyBackupSuccess     bool   `json:"notifyBackupSuccess"`
	NotifyBackupFailure     bool   `json:"notifyBackupFailure"`
	NotifyS3ConnectionIssue bool   `json:"notifyS3ConnectionIssue"`
}

func (q *Queries) CreateNotificationProvider(ctx context.Context, arg *CreateNotificationProviderParams) (*NotificationProvider, error) {
	row := q.db.QueryRowContext(ctx, CreateNotificationProvider,
		arg.Type,
		arg.Name,
		arg.Config,
		arg.IsDefault,
		arg.NotifyNodeDowntime,
		arg.NotifyBackupSuccess,
		arg.NotifyBackupFailure,
		arg.NotifyS3ConnectionIssue,
	)
	var i NotificationProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Config,
		&i.IsDefault,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotifyNodeDowntime,
		&i.NotifyBackupSuccess,
		&i.NotifyBackupFailure,
		&i.NotifyS3ConnectionIssue,
		&i.LastTestAt,
		&i.LastTestStatus,
		&i.LastTestMessage,
	)
	return &i, err
}

const CreatePlugin = `-- name: CreatePlugin :one
INSERT INTO plugins (
  name,
  api_version,
  kind,
  metadata,
  spec,
  created_at,
  updated_at
) VALUES (
  ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
) RETURNING name, api_version, kind, metadata, spec, created_at, updated_at, deployment_metadata, deployment_status
`

type CreatePluginParams struct {
	Name       string      `json:"name"`
	ApiVersion string      `json:"apiVersion"`
	Kind       string      `json:"kind"`
	Metadata   interface{} `json:"metadata"`
	Spec       interface{} `json:"spec"`
}

func (q *Queries) CreatePlugin(ctx context.Context, arg *CreatePluginParams) (*Plugin, error) {
	row := q.db.QueryRowContext(ctx, CreatePlugin,
		arg.Name,
		arg.ApiVersion,
		arg.Kind,
		arg.Metadata,
		arg.Spec,
	)
	var i Plugin
	err := row.Scan(
		&i.Name,
		&i.ApiVersion,
		&i.Kind,
		&i.Metadata,
		&i.Spec,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeploymentMetadata,
		&i.DeploymentStatus,
	)
	return &i, err
}

const CreateSession = `-- name: CreateSession :one
INSERT INTO sessions (
  token,
  user_id,
  expires_at,
  session_id
) VALUES (
  ?, ?, ?, ?
)
RETURNING id, session_id, user_id, token, ip_address, user_agent, created_at, updated_at, expires_at, last_activity_at
`

type CreateSessionParams struct {
	Token     string    `json:"token"`
	UserID    int64     `json:"userId"`
	ExpiresAt time.Time `json:"expiresAt"`
	SessionID string    `json:"sessionId"`
}

func (q *Queries) CreateSession(ctx context.Context, arg *CreateSessionParams) (*Session, error) {
	row := q.db.QueryRowContext(ctx, CreateSession,
		arg.Token,
		arg.UserID,
		arg.ExpiresAt,
		arg.SessionID,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.UserID,
		&i.Token,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.LastActivityAt,
	)
	return &i, err
}

const CreateSetting = `-- name: CreateSetting :one
INSERT INTO settings (
    config
) VALUES (
    ?
)
RETURNING id, config, created_at, updated_at
`

func (q *Queries) CreateSetting(ctx context.Context, config string) (*Setting, error) {
	row := q.db.QueryRowContext(ctx, CreateSetting, config)
	var i Setting
	err := row.Scan(
		&i.ID,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CreateUser = `-- name: CreateUser :one
INSERT INTO users (
    username, password, role, created_at, last_login_at, updated_at
) VALUES (
    ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
)
RETURNING id, username, password, name, email, role, provider, provider_id, avatar_url, created_at, last_login_at, updated_at
`

type CreateUserParams struct {
	Username string         `json:"username"`
	Password string         `json:"password"`
	Role     sql.NullString `json:"role"`
}

func (q *Queries) CreateUser(ctx context.Context, arg *CreateUserParams) (*User, error) {
	row := q.db.QueryRowContext(ctx, CreateUser, arg.Username, arg.Password, arg.Role)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Name,
		&i.Email,
		&i.Role,
		&i.Provider,
		&i.ProviderID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.LastLoginAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const DeleteBackup = `-- name: DeleteBackup :exec
DELETE FROM backups WHERE id = ?
`

func (q *Queries) DeleteBackup(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, DeleteBackup, id)
	return err
}

const DeleteBackupSchedule = `-- name: DeleteBackupSchedule :exec
DELETE FROM backup_schedules WHERE id = ?
`

func (q *Queries) DeleteBackupSchedule(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, DeleteBackupSchedule, id)
	return err
}

const DeleteBackupTarget = `-- name: DeleteBackupTarget :exec
DELETE FROM backup_targets WHERE id = ?
`

func (q *Queries) DeleteBackupTarget(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, DeleteBackupTarget, id)
	return err
}

const DeleteBackupsBySchedule = `-- name: DeleteBackupsBySchedule :exec
DELETE FROM backups
WHERE schedule_id = ?
`

func (q *Queries) DeleteBackupsBySchedule(ctx context.Context, scheduleID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, DeleteBackupsBySchedule, scheduleID)
	return err
}

const DeleteBackupsByTarget = `-- name: DeleteBackupsByTarget :exec
DELETE FROM backups
WHERE target_id = ?
`

func (q *Queries) DeleteBackupsByTarget(ctx context.Context, targetID int64) error {
	_, err := q.db.ExecContext(ctx, DeleteBackupsByTarget, targetID)
	return err
}

const DeleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM sessions WHERE expires_at < CURRENT_TIMESTAMP
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, DeleteExpiredSessions)
	return err
}

const DeleteFabricOrganization = `-- name: DeleteFabricOrganization :exec
DELETE FROM fabric_organizations WHERE id = ?
`

func (q *Queries) DeleteFabricOrganization(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, DeleteFabricOrganization, id)
	return err
}

const DeleteKey = `-- name: DeleteKey :exec
DELETE FROM keys WHERE id = ?
`

func (q *Queries) DeleteKey(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, DeleteKey, id)
	return err
}

const DeleteKeyProvider = `-- name: DeleteKeyProvider :exec
DELETE FROM key_providers WHERE id = ?
`

func (q *Queries) DeleteKeyProvider(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, DeleteKeyProvider, id)
	return err
}

const DeleteNetwork = `-- name: DeleteNetwork :exec
DELETE FROM networks
WHERE id = ?
`

func (q *Queries) DeleteNetwork(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, DeleteNetwork, id)
	return err
}

const DeleteNetworkNode = `-- name: DeleteNetworkNode :exec
DELETE FROM network_nodes
WHERE network_id = ? AND node_id = ?
`

type DeleteNetworkNodeParams struct {
	NetworkID int64 `json:"networkId"`
	NodeID    int64 `json:"nodeId"`
}

func (q *Queries) DeleteNetworkNode(ctx context.Context, arg *DeleteNetworkNodeParams) error {
	_, err := q.db.ExecContext(ctx, DeleteNetworkNode, arg.NetworkID, arg.NodeID)
	return err
}

const DeleteNode = `-- name: DeleteNode :exec
DELETE FROM nodes WHERE id = ?
`

func (q *Queries) DeleteNode(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, DeleteNode, id)
	return err
}

const DeleteNotificationProvider = `-- name: DeleteNotificationProvider :exec
DELETE FROM notification_providers
WHERE id = ?
`

func (q *Queries) DeleteNotificationProvider(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, DeleteNotificationProvider, id)
	return err
}

const DeleteOldBackups = `-- name: DeleteOldBackups :exec
DELETE FROM backups
WHERE target_id = ? 
AND created_at < ?
`

type DeleteOldBackupsParams struct {
	TargetID  int64     `json:"targetId"`
	CreatedAt time.Time `json:"createdAt"`
}

func (q *Queries) DeleteOldBackups(ctx context.Context, arg *DeleteOldBackupsParams) error {
	_, err := q.db.ExecContext(ctx, DeleteOldBackups, arg.TargetID, arg.CreatedAt)
	return err
}

const DeletePlugin = `-- name: DeletePlugin :exec
DELETE FROM plugins WHERE name = ?
`

func (q *Queries) DeletePlugin(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, DeletePlugin, name)
	return err
}

const DeleteRevokedCertificate = `-- name: DeleteRevokedCertificate :exec
DELETE FROM fabric_revoked_certificates
WHERE fabric_organization_id = ? AND serial_number = ?
`

type DeleteRevokedCertificateParams struct {
	FabricOrganizationID int64  `json:"fabricOrganizationId"`
	SerialNumber         string `json:"serialNumber"`
}

func (q *Queries) DeleteRevokedCertificate(ctx context.Context, arg *DeleteRevokedCertificateParams) error {
	_, err := q.db.ExecContext(ctx, DeleteRevokedCertificate, arg.FabricOrganizationID, arg.SerialNumber)
	return err
}

const DeleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE token = ?
`

func (q *Queries) DeleteSession(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, DeleteSession, token)
	return err
}

const DeleteSetting = `-- name: DeleteSetting :exec
DELETE FROM settings
WHERE id = ?
`

func (q *Queries) DeleteSetting(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, DeleteSetting, id)
	return err
}

const DeleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, DeleteUser, id)
	return err
}

const DeleteUserSessions = `-- name: DeleteUserSessions :exec
DELETE FROM sessions WHERE user_id = ?
`

func (q *Queries) DeleteUserSessions(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, DeleteUserSessions, userID)
	return err
}

const DisableBackupSchedule = `-- name: DisableBackupSchedule :one
UPDATE backup_schedules
SET enabled = false,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, description, cron_expression, target_id, retention_days, enabled, created_at, updated_at, last_run_at, next_run_at
`

func (q *Queries) DisableBackupSchedule(ctx context.Context, id int64) (*BackupSchedule, error) {
	row := q.db.QueryRowContext(ctx, DisableBackupSchedule, id)
	var i BackupSchedule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CronExpression,
		&i.TargetID,
		&i.RetentionDays,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastRunAt,
		&i.NextRunAt,
	)
	return &i, err
}

const EnableBackupSchedule = `-- name: EnableBackupSchedule :one
UPDATE backup_schedules
SET enabled = true,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, description, cron_expression, target_id, retention_days, enabled, created_at, updated_at, last_run_at, next_run_at
`

func (q *Queries) EnableBackupSchedule(ctx context.Context, id int64) (*BackupSchedule, error) {
	row := q.db.QueryRowContext(ctx, EnableBackupSchedule, id)
	var i BackupSchedule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CronExpression,
		&i.TargetID,
		&i.RetentionDays,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastRunAt,
		&i.NextRunAt,
	)
	return &i, err
}

const GetAllKeys = `-- name: GetAllKeys :many
SELECT k.id, k.name, k.description, k.algorithm, k.key_size, k.curve, k.format, k.public_key, k.private_key, k.certificate, k.status, k.created_at, k.updated_at, k.expires_at, k.last_rotated_at, k.signing_key_id, k.sha256_fingerprint, k.sha1_fingerprint, k.provider_id, k.user_id, k.is_ca, k.ethereum_address, kp.name as provider_name, kp.type as provider_type
FROM keys k
JOIN key_providers kp ON k.provider_id = kp.id
WHERE (? IS NULL OR k.provider_id = ?)
`

type GetAllKeysParams struct {
	Column1    interface{} `json:"column1"`
	ProviderID int64       `json:"providerId"`
}

type GetAllKeysRow struct {
	ID                int64          `json:"id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Algorithm         string         `json:"algorithm"`
	KeySize           sql.NullInt64  `json:"keySize"`
	Curve             sql.NullString `json:"curve"`
	Format            string         `json:"format"`
	PublicKey         string         `json:"publicKey"`
	PrivateKey        string         `json:"privateKey"`
	Certificate       sql.NullString `json:"certificate"`
	Status            string         `json:"status"`
	CreatedAt         time.Time      `json:"createdAt"`
	UpdatedAt         time.Time      `json:"updatedAt"`
	ExpiresAt         sql.NullTime   `json:"expiresAt"`
	LastRotatedAt     sql.NullTime   `json:"lastRotatedAt"`
	SigningKeyID      sql.NullInt64  `json:"signingKeyId"`
	Sha256Fingerprint string         `json:"sha256Fingerprint"`
	Sha1Fingerprint   string         `json:"sha1Fingerprint"`
	ProviderID        int64          `json:"providerId"`
	UserID            int64          `json:"userId"`
	IsCa              int64          `json:"isCa"`
	EthereumAddress   sql.NullString `json:"ethereumAddress"`
	ProviderName      string         `json:"providerName"`
	ProviderType      string         `json:"providerType"`
}

func (q *Queries) GetAllKeys(ctx context.Context, arg *GetAllKeysParams) ([]*GetAllKeysRow, error) {
	rows, err := q.db.QueryContext(ctx, GetAllKeys, arg.Column1, arg.ProviderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAllKeysRow{}
	for rows.Next() {
		var i GetAllKeysRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Algorithm,
			&i.KeySize,
			&i.Curve,
			&i.Format,
			&i.PublicKey,
			&i.PrivateKey,
			&i.Certificate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
			&i.LastRotatedAt,
			&i.SigningKeyID,
			&i.Sha256Fingerprint,
			&i.Sha1Fingerprint,
			&i.ProviderID,
			&i.UserID,
			&i.IsCa,
			&i.EthereumAddress,
			&i.ProviderName,
			&i.ProviderType,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAllNodes = `-- name: GetAllNodes :many
SELECT id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config, error_message FROM nodes
`

func (q *Queries) GetAllNodes(ctx context.Context) ([]*Node, error) {
	rows, err := q.db.QueryContext(ctx, GetAllNodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Platform,
			&i.Status,
			&i.Description,
			&i.NetworkID,
			&i.Config,
			&i.Resources,
			&i.Endpoint,
			&i.PublicEndpoint,
			&i.P2pAddress,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.FabricOrganizationID,
			&i.NodeType,
			&i.NodeConfig,
			&i.DeploymentConfig,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAuditLog = `-- name: GetAuditLog :one
SELECT id, timestamp, event_source, user_identity, source_ip, event_type, event_outcome, affected_resource, request_id, severity, details, created_at, updated_at FROM audit_logs
WHERE id = ? LIMIT 1
`

func (q *Queries) GetAuditLog(ctx context.Context, id int64) (*AuditLog, error) {
	row := q.db.QueryRowContext(ctx, GetAuditLog, id)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.Timestamp,
		&i.EventSource,
		&i.UserIdentity,
		&i.SourceIp,
		&i.EventType,
		&i.EventOutcome,
		&i.AffectedResource,
		&i.RequestID,
		&i.Severity,
		&i.Details,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetBackup = `-- name: GetBackup :one
SELECT id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent FROM backups
WHERE id = ? LIMIT 1
`

func (q *Queries) GetBackup(ctx context.Context, id int64) (*Backup, error) {
	row := q.db.QueryRowContext(ctx, GetBackup, id)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.ScheduleID,
		&i.TargetID,
		&i.Status,
		&i.SizeBytes,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.NotificationSent,
	)
	return &i, err
}

const GetBackupSchedule = `-- name: GetBackupSchedule :one
SELECT id, name, description, cron_expression, target_id, retention_days, enabled, created_at, updated_at, last_run_at, next_run_at FROM backup_schedules
WHERE id = ? LIMIT 1
`

func (q *Queries) GetBackupSchedule(ctx context.Context, id int64) (*BackupSchedule, error) {
	row := q.db.QueryRowContext(ctx, GetBackupSchedule, id)
	var i BackupSchedule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CronExpression,
		&i.TargetID,
		&i.RetentionDays,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastRunAt,
		&i.NextRunAt,
	)
	return &i, err
}

const GetBackupTarget = `-- name: GetBackupTarget :one
SELECT id, name, bucket_name, region, endpoint, bucket_path, access_key_id, secret_key, s3_path_style, restic_password, type, created_at, updated_at FROM backup_targets
WHERE id = ? LIMIT 1
`

func (q *Queries) GetBackupTarget(ctx context.Context, id int64) (*BackupTarget, error) {
	row := q.db.QueryRowContext(ctx, GetBackupTarget, id)
	var i BackupTarget
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BucketName,
		&i.Region,
		&i.Endpoint,
		&i.BucketPath,
		&i.AccessKeyID,
		&i.SecretKey,
		&i.S3PathStyle,
		&i.ResticPassword,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetBackupsByDateRange = `-- name: GetBackupsByDateRange :many
SELECT id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent FROM backups
WHERE created_at BETWEEN ? AND ?
ORDER BY created_at DESC
`

type GetBackupsByDateRangeParams struct {
	FromCreatedAt time.Time `json:"fromCreatedAt"`
	ToCreatedAt   time.Time `json:"toCreatedAt"`
}

func (q *Queries) GetBackupsByDateRange(ctx context.Context, arg *GetBackupsByDateRangeParams) ([]*Backup, error) {
	rows, err := q.db.QueryContext(ctx, GetBackupsByDateRange, arg.FromCreatedAt, arg.ToCreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Backup{}
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.ID,
			&i.ScheduleID,
			&i.TargetID,
			&i.Status,
			&i.SizeBytes,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.NotificationSent,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetBackupsByScheduleAndStatus = `-- name: GetBackupsByScheduleAndStatus :many
SELECT id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent FROM backups
WHERE schedule_id = ? AND status = ?
ORDER BY created_at DESC
`

type GetBackupsByScheduleAndStatusParams struct {
	ScheduleID sql.NullInt64 `json:"scheduleId"`
	Status     string        `json:"status"`
}

func (q *Queries) GetBackupsByScheduleAndStatus(ctx context.Context, arg *GetBackupsByScheduleAndStatusParams) ([]*Backup, error) {
	rows, err := q.db.QueryContext(ctx, GetBackupsByScheduleAndStatus, arg.ScheduleID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Backup{}
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.ID,
			&i.ScheduleID,
			&i.TargetID,
			&i.Status,
			&i.SizeBytes,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.NotificationSent,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetBackupsByStatus = `-- name: GetBackupsByStatus :many
SELECT id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent FROM backups
WHERE status = ?
ORDER BY created_at DESC
`

func (q *Queries) GetBackupsByStatus(ctx context.Context, status string) ([]*Backup, error) {
	rows, err := q.db.QueryContext(ctx, GetBackupsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Backup{}
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.ID,
			&i.ScheduleID,
			&i.TargetID,
			&i.Status,
			&i.SizeBytes,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.NotificationSent,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetDefaultNotificationProvider = `-- name: GetDefaultNotificationProvider :one
SELECT id, name, type, config, is_default, is_enabled, created_at, updated_at, notify_node_downtime, notify_backup_success, notify_backup_failure, notify_s3_connection_issue, last_test_at, last_test_status, last_test_message FROM notification_providers
WHERE is_default = 1 AND type = ?
LIMIT 1
`

func (q *Queries) GetDefaultNotificationProvider(ctx context.Context, type_ string) (*NotificationProvider, error) {
	row := q.db.QueryRowContext(ctx, GetDefaultNotificationProvider, type_)
	var i NotificationProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Config,
		&i.IsDefault,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotifyNodeDowntime,
		&i.NotifyBackupSuccess,
		&i.NotifyBackupFailure,
		&i.NotifyS3ConnectionIssue,
		&i.LastTestAt,
		&i.LastTestStatus,
		&i.LastTestMessage,
	)
	return &i, err
}

const GetDefaultNotificationProviderForType = `-- name: GetDefaultNotificationProviderForType :one
SELECT id, name, type, config, is_default, is_enabled, created_at, updated_at, notify_node_downtime, notify_backup_success, notify_backup_failure, notify_s3_connection_issue, last_test_at, last_test_status, last_test_message FROM notification_providers
WHERE is_default = true
  AND (
    (?1 = 'BACKUP_SUCCESS' AND notify_backup_success = true) OR
    (?1 = 'BACKUP_FAILURE' AND notify_backup_failure = true) OR
    (?1 = 'NODE_DOWNTIME' AND notify_node_downtime = true) OR
    (?1 = 'S3_CONNECTION_ISSUE' AND notify_s3_connection_issue = true)
  )
LIMIT 1
`

func (q *Queries) GetDefaultNotificationProviderForType(ctx context.Context, notificationType interface{}) (*NotificationProvider, error) {
	row := q.db.QueryRowContext(ctx, GetDefaultNotificationProviderForType, notificationType)
	var i NotificationProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Config,
		&i.IsDefault,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotifyNodeDowntime,
		&i.NotifyBackupSuccess,
		&i.NotifyBackupFailure,
		&i.NotifyS3ConnectionIssue,
		&i.LastTestAt,
		&i.LastTestStatus,
		&i.LastTestMessage,
	)
	return &i, err
}

const GetDeploymentMetadata = `-- name: GetDeploymentMetadata :one
SELECT deployment_metadata
FROM plugins
WHERE name = ?
`

func (q *Queries) GetDeploymentMetadata(ctx context.Context, name string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, GetDeploymentMetadata, name)
	var deployment_metadata interface{}
	err := row.Scan(&deployment_metadata)
	return deployment_metadata, err
}

const GetDeploymentStatus = `-- name: GetDeploymentStatus :one
SELECT deployment_status
FROM plugins
WHERE name = ?
`

func (q *Queries) GetDeploymentStatus(ctx context.Context, name string) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, GetDeploymentStatus, name)
	var deployment_status sql.NullString
	err := row.Scan(&deployment_status)
	return deployment_status, err
}

const GetFabricOrganization = `-- name: GetFabricOrganization :one
SELECT id, msp_id, description, config, ca_config, sign_key_id, tls_root_key_id, admin_tls_key_id, admin_sign_key_id, client_sign_key_id, provider_id, created_at, created_by, updated_at, crl_key_id, crl_last_update FROM fabric_organizations
WHERE id = ? LIMIT 1
`

func (q *Queries) GetFabricOrganization(ctx context.Context, id int64) (*FabricOrganization, error) {
	row := q.db.QueryRowContext(ctx, GetFabricOrganization, id)
	var i FabricOrganization
	err := row.Scan(
		&i.ID,
		&i.MspID,
		&i.Description,
		&i.Config,
		&i.CaConfig,
		&i.SignKeyID,
		&i.TlsRootKeyID,
		&i.AdminTlsKeyID,
		&i.AdminSignKeyID,
		&i.ClientSignKeyID,
		&i.ProviderID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.CrlKeyID,
		&i.CrlLastUpdate,
	)
	return &i, err
}

const GetFabricOrganizationByID = `-- name: GetFabricOrganizationByID :one
SELECT id, msp_id, description, config, ca_config, sign_key_id, tls_root_key_id, admin_tls_key_id, admin_sign_key_id, client_sign_key_id, provider_id, created_at, created_by, updated_at, crl_key_id, crl_last_update FROM fabric_organizations WHERE id = ? LIMIT 1
`

func (q *Queries) GetFabricOrganizationByID(ctx context.Context, id int64) (*FabricOrganization, error) {
	row := q.db.QueryRowContext(ctx, GetFabricOrganizationByID, id)
	var i FabricOrganization
	err := row.Scan(
		&i.ID,
		&i.MspID,
		&i.Description,
		&i.Config,
		&i.CaConfig,
		&i.SignKeyID,
		&i.TlsRootKeyID,
		&i.AdminTlsKeyID,
		&i.AdminSignKeyID,
		&i.ClientSignKeyID,
		&i.ProviderID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.CrlKeyID,
		&i.CrlLastUpdate,
	)
	return &i, err
}

const GetFabricOrganizationByMSPID = `-- name: GetFabricOrganizationByMSPID :one
SELECT id, msp_id, description, config, ca_config, sign_key_id, tls_root_key_id, admin_tls_key_id, admin_sign_key_id, client_sign_key_id, provider_id, created_at, created_by, updated_at, crl_key_id, crl_last_update FROM fabric_organizations
WHERE msp_id = ? LIMIT 1
`

func (q *Queries) GetFabricOrganizationByMSPID(ctx context.Context, mspID string) (*FabricOrganization, error) {
	row := q.db.QueryRowContext(ctx, GetFabricOrganizationByMSPID, mspID)
	var i FabricOrganization
	err := row.Scan(
		&i.ID,
		&i.MspID,
		&i.Description,
		&i.Config,
		&i.CaConfig,
		&i.SignKeyID,
		&i.TlsRootKeyID,
		&i.AdminTlsKeyID,
		&i.AdminSignKeyID,
		&i.ClientSignKeyID,
		&i.ProviderID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.CrlKeyID,
		&i.CrlLastUpdate,
	)
	return &i, err
}

const GetFabricOrganizationByMspID = `-- name: GetFabricOrganizationByMspID :one
SELECT 
    fo.id, fo.msp_id, fo.description, fo.config, fo.ca_config, fo.sign_key_id, fo.tls_root_key_id, fo.admin_tls_key_id, fo.admin_sign_key_id, fo.client_sign_key_id, fo.provider_id, fo.created_at, fo.created_by, fo.updated_at, fo.crl_key_id, fo.crl_last_update,
    sk.public_key as sign_public_key,
    sk.certificate as sign_certificate,
    tk.public_key as tls_public_key,
    tk.certificate as tls_certificate,
    p.name as provider_name
FROM fabric_organizations fo
LEFT JOIN keys sk ON fo.sign_key_id = sk.id
LEFT JOIN keys tk ON fo.tls_root_key_id = tk.id
LEFT JOIN key_providers p ON fo.provider_id = p.id
WHERE fo.msp_id = ?
`

type GetFabricOrganizationByMspIDRow struct {
	ID              int64          `json:"id"`
	MspID           string         `json:"mspId"`
	Description     sql.NullString `json:"description"`
	Config          sql.NullString `json:"config"`
	CaConfig        sql.NullString `json:"caConfig"`
	SignKeyID       sql.NullInt64  `json:"signKeyId"`
	TlsRootKeyID    sql.NullInt64  `json:"tlsRootKeyId"`
	AdminTlsKeyID   sql.NullInt64  `json:"adminTlsKeyId"`
	AdminSignKeyID  sql.NullInt64  `json:"adminSignKeyId"`
	ClientSignKeyID sql.NullInt64  `json:"clientSignKeyId"`
	ProviderID      sql.NullInt64  `json:"providerId"`
	CreatedAt       time.Time      `json:"createdAt"`
	CreatedBy       sql.NullInt64  `json:"createdBy"`
	UpdatedAt       sql.NullTime   `json:"updatedAt"`
	CrlKeyID        sql.NullInt64  `json:"crlKeyId"`
	CrlLastUpdate   sql.NullTime   `json:"crlLastUpdate"`
	SignPublicKey   sql.NullString `json:"signPublicKey"`
	SignCertificate sql.NullString `json:"signCertificate"`
	TlsPublicKey    sql.NullString `json:"tlsPublicKey"`
	TlsCertificate  sql.NullString `json:"tlsCertificate"`
	ProviderName    sql.NullString `json:"providerName"`
}

func (q *Queries) GetFabricOrganizationByMspID(ctx context.Context, mspID string) (*GetFabricOrganizationByMspIDRow, error) {
	row := q.db.QueryRowContext(ctx, GetFabricOrganizationByMspID, mspID)
	var i GetFabricOrganizationByMspIDRow
	err := row.Scan(
		&i.ID,
		&i.MspID,
		&i.Description,
		&i.Config,
		&i.CaConfig,
		&i.SignKeyID,
		&i.TlsRootKeyID,
		&i.AdminTlsKeyID,
		&i.AdminSignKeyID,
		&i.ClientSignKeyID,
		&i.ProviderID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.CrlKeyID,
		&i.CrlLastUpdate,
		&i.SignPublicKey,
		&i.SignCertificate,
		&i.TlsPublicKey,
		&i.TlsCertificate,
		&i.ProviderName,
	)
	return &i, err
}

const GetFabricOrganizationWithKeys = `-- name: GetFabricOrganizationWithKeys :one
SELECT 
    fo.id, fo.msp_id, fo.description, fo.config, fo.ca_config, fo.sign_key_id, fo.tls_root_key_id, fo.admin_tls_key_id, fo.admin_sign_key_id, fo.client_sign_key_id, fo.provider_id, fo.created_at, fo.created_by, fo.updated_at, fo.crl_key_id, fo.crl_last_update,
    sk.public_key as sign_public_key,
    sk.certificate as sign_certificate,
    tk.public_key as tls_public_key,
    tk.certificate as tls_certificate,
    p.name as provider_name
FROM fabric_organizations fo
LEFT JOIN keys sk ON fo.sign_key_id = sk.id
LEFT JOIN keys tk ON fo.tls_root_key_id = tk.id
LEFT JOIN key_providers p ON fo.provider_id = p.id
WHERE fo.id = ?
`

type GetFabricOrganizationWithKeysRow struct {
	ID              int64          `json:"id"`
	MspID           string         `json:"mspId"`
	Description     sql.NullString `json:"description"`
	Config          sql.NullString `json:"config"`
	CaConfig        sql.NullString `json:"caConfig"`
	SignKeyID       sql.NullInt64  `json:"signKeyId"`
	TlsRootKeyID    sql.NullInt64  `json:"tlsRootKeyId"`
	AdminTlsKeyID   sql.NullInt64  `json:"adminTlsKeyId"`
	AdminSignKeyID  sql.NullInt64  `json:"adminSignKeyId"`
	ClientSignKeyID sql.NullInt64  `json:"clientSignKeyId"`
	ProviderID      sql.NullInt64  `json:"providerId"`
	CreatedAt       time.Time      `json:"createdAt"`
	CreatedBy       sql.NullInt64  `json:"createdBy"`
	UpdatedAt       sql.NullTime   `json:"updatedAt"`
	CrlKeyID        sql.NullInt64  `json:"crlKeyId"`
	CrlLastUpdate   sql.NullTime   `json:"crlLastUpdate"`
	SignPublicKey   sql.NullString `json:"signPublicKey"`
	SignCertificate sql.NullString `json:"signCertificate"`
	TlsPublicKey    sql.NullString `json:"tlsPublicKey"`
	TlsCertificate  sql.NullString `json:"tlsCertificate"`
	ProviderName    sql.NullString `json:"providerName"`
}

func (q *Queries) GetFabricOrganizationWithKeys(ctx context.Context, id int64) (*GetFabricOrganizationWithKeysRow, error) {
	row := q.db.QueryRowContext(ctx, GetFabricOrganizationWithKeys, id)
	var i GetFabricOrganizationWithKeysRow
	err := row.Scan(
		&i.ID,
		&i.MspID,
		&i.Description,
		&i.Config,
		&i.CaConfig,
		&i.SignKeyID,
		&i.TlsRootKeyID,
		&i.AdminTlsKeyID,
		&i.AdminSignKeyID,
		&i.ClientSignKeyID,
		&i.ProviderID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.CrlKeyID,
		&i.CrlLastUpdate,
		&i.SignPublicKey,
		&i.SignCertificate,
		&i.TlsPublicKey,
		&i.TlsCertificate,
		&i.ProviderName,
	)
	return &i, err
}

const GetKey = `-- name: GetKey :one
SELECT k.id, k.name, k.description, k.algorithm, k.key_size, k.curve, k.format, k.public_key, k.private_key, k.certificate, k.status, k.created_at, k.updated_at, k.expires_at, k.last_rotated_at, k.signing_key_id, k.sha256_fingerprint, k.sha1_fingerprint, k.provider_id, k.user_id, k.is_ca, k.ethereum_address, kp.name as provider_name, kp.type as provider_type
FROM keys k
JOIN key_providers kp ON k.provider_id = kp.id
WHERE k.id = ?
`

type GetKeyRow struct {
	ID                int64          `json:"id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Algorithm         string         `json:"algorithm"`
	KeySize           sql.NullInt64  `json:"keySize"`
	Curve             sql.NullString `json:"curve"`
	Format            string         `json:"format"`
	PublicKey         string         `json:"publicKey"`
	PrivateKey        string         `json:"privateKey"`
	Certificate       sql.NullString `json:"certificate"`
	Status            string         `json:"status"`
	CreatedAt         time.Time      `json:"createdAt"`
	UpdatedAt         time.Time      `json:"updatedAt"`
	ExpiresAt         sql.NullTime   `json:"expiresAt"`
	LastRotatedAt     sql.NullTime   `json:"lastRotatedAt"`
	SigningKeyID      sql.NullInt64  `json:"signingKeyId"`
	Sha256Fingerprint string         `json:"sha256Fingerprint"`
	Sha1Fingerprint   string         `json:"sha1Fingerprint"`
	ProviderID        int64          `json:"providerId"`
	UserID            int64          `json:"userId"`
	IsCa              int64          `json:"isCa"`
	EthereumAddress   sql.NullString `json:"ethereumAddress"`
	ProviderName      string         `json:"providerName"`
	ProviderType      string         `json:"providerType"`
}

func (q *Queries) GetKey(ctx context.Context, id int64) (*GetKeyRow, error) {
	row := q.db.QueryRowContext(ctx, GetKey, id)
	var i GetKeyRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Algorithm,
		&i.KeySize,
		&i.Curve,
		&i.Format,
		&i.PublicKey,
		&i.PrivateKey,
		&i.Certificate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.LastRotatedAt,
		&i.SigningKeyID,
		&i.Sha256Fingerprint,
		&i.Sha1Fingerprint,
		&i.ProviderID,
		&i.UserID,
		&i.IsCa,
		&i.EthereumAddress,
		&i.ProviderName,
		&i.ProviderType,
	)
	return &i, err
}

const GetKeyByEthereumAddress = `-- name: GetKeyByEthereumAddress :one
SELECT k.id, k.name, k.description, k.algorithm, k.key_size, k.curve, k.format, k.public_key, k.private_key, k.certificate, k.status, k.created_at, k.updated_at, k.expires_at, k.last_rotated_at, k.signing_key_id, k.sha256_fingerprint, k.sha1_fingerprint, k.provider_id, k.user_id, k.is_ca, k.ethereum_address, kp.name as provider_name, kp.type as provider_type
FROM keys k
JOIN key_providers kp ON k.provider_id = kp.id
WHERE k.ethereum_address = ?
`

type GetKeyByEthereumAddressRow struct {
	ID                int64          `json:"id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Algorithm         string         `json:"algorithm"`
	KeySize           sql.NullInt64  `json:"keySize"`
	Curve             sql.NullString `json:"curve"`
	Format            string         `json:"format"`
	PublicKey         string         `json:"publicKey"`
	PrivateKey        string         `json:"privateKey"`
	Certificate       sql.NullString `json:"certificate"`
	Status            string         `json:"status"`
	CreatedAt         time.Time      `json:"createdAt"`
	UpdatedAt         time.Time      `json:"updatedAt"`
	ExpiresAt         sql.NullTime   `json:"expiresAt"`
	LastRotatedAt     sql.NullTime   `json:"lastRotatedAt"`
	SigningKeyID      sql.NullInt64  `json:"signingKeyId"`
	Sha256Fingerprint string         `json:"sha256Fingerprint"`
	Sha1Fingerprint   string         `json:"sha1Fingerprint"`
	ProviderID        int64          `json:"providerId"`
	UserID            int64          `json:"userId"`
	IsCa              int64          `json:"isCa"`
	EthereumAddress   sql.NullString `json:"ethereumAddress"`
	ProviderName      string         `json:"providerName"`
	ProviderType      string         `json:"providerType"`
}

func (q *Queries) GetKeyByEthereumAddress(ctx context.Context, ethereumAddress sql.NullString) (*GetKeyByEthereumAddressRow, error) {
	row := q.db.QueryRowContext(ctx, GetKeyByEthereumAddress, ethereumAddress)
	var i GetKeyByEthereumAddressRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Algorithm,
		&i.KeySize,
		&i.Curve,
		&i.Format,
		&i.PublicKey,
		&i.PrivateKey,
		&i.Certificate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.LastRotatedAt,
		&i.SigningKeyID,
		&i.Sha256Fingerprint,
		&i.Sha1Fingerprint,
		&i.ProviderID,
		&i.UserID,
		&i.IsCa,
		&i.EthereumAddress,
		&i.ProviderName,
		&i.ProviderType,
	)
	return &i, err
}

const GetKeyByID = `-- name: GetKeyByID :one
SELECT k.id, k.name, k.description, k.algorithm, k.key_size, k.curve, k.format, k.public_key, k.private_key, k.certificate, k.status, k.created_at, k.updated_at, k.expires_at, k.last_rotated_at, k.signing_key_id, k.sha256_fingerprint, k.sha1_fingerprint, k.provider_id, k.user_id, k.is_ca, k.ethereum_address, kp.name as provider_name, kp.type as provider_type
FROM keys k
JOIN key_providers kp ON k.provider_id = kp.id
WHERE k.id = ?
`

type GetKeyByIDRow struct {
	ID                int64          `json:"id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Algorithm         string         `json:"algorithm"`
	KeySize           sql.NullInt64  `json:"keySize"`
	Curve             sql.NullString `json:"curve"`
	Format            string         `json:"format"`
	PublicKey         string         `json:"publicKey"`
	PrivateKey        string         `json:"privateKey"`
	Certificate       sql.NullString `json:"certificate"`
	Status            string         `json:"status"`
	CreatedAt         time.Time      `json:"createdAt"`
	UpdatedAt         time.Time      `json:"updatedAt"`
	ExpiresAt         sql.NullTime   `json:"expiresAt"`
	LastRotatedAt     sql.NullTime   `json:"lastRotatedAt"`
	SigningKeyID      sql.NullInt64  `json:"signingKeyId"`
	Sha256Fingerprint string         `json:"sha256Fingerprint"`
	Sha1Fingerprint   string         `json:"sha1Fingerprint"`
	ProviderID        int64          `json:"providerId"`
	UserID            int64          `json:"userId"`
	IsCa              int64          `json:"isCa"`
	EthereumAddress   sql.NullString `json:"ethereumAddress"`
	ProviderName      string         `json:"providerName"`
	ProviderType      string         `json:"providerType"`
}

func (q *Queries) GetKeyByID(ctx context.Context, id int64) (*GetKeyByIDRow, error) {
	row := q.db.QueryRowContext(ctx, GetKeyByID, id)
	var i GetKeyByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Algorithm,
		&i.KeySize,
		&i.Curve,
		&i.Format,
		&i.PublicKey,
		&i.PrivateKey,
		&i.Certificate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.LastRotatedAt,
		&i.SigningKeyID,
		&i.Sha256Fingerprint,
		&i.Sha1Fingerprint,
		&i.ProviderID,
		&i.UserID,
		&i.IsCa,
		&i.EthereumAddress,
		&i.ProviderName,
		&i.ProviderType,
	)
	return &i, err
}

const GetKeyCountByProvider = `-- name: GetKeyCountByProvider :one
SELECT COUNT(*) FROM keys WHERE provider_id = ?
`

func (q *Queries) GetKeyCountByProvider(ctx context.Context, providerID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetKeyCountByProvider, providerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetKeyProvider = `-- name: GetKeyProvider :one
SELECT id, name, type, is_default, config, created_at, updated_at FROM key_providers WHERE id = ?
`

func (q *Queries) GetKeyProvider(ctx context.Context, id int64) (*KeyProvider, error) {
	row := q.db.QueryRowContext(ctx, GetKeyProvider, id)
	var i KeyProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.IsDefault,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetKeyProviderByDefault = `-- name: GetKeyProviderByDefault :one
SELECT id, name, type, is_default, config, created_at, updated_at FROM key_providers WHERE is_default = 1 LIMIT 1
`

func (q *Queries) GetKeyProviderByDefault(ctx context.Context) (*KeyProvider, error) {
	row := q.db.QueryRowContext(ctx, GetKeyProviderByDefault)
	var i KeyProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.IsDefault,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetKeyProviderByID = `-- name: GetKeyProviderByID :one
SELECT id, name, type, is_default, config, created_at, updated_at FROM key_providers WHERE id = ?
`

func (q *Queries) GetKeyProviderByID(ctx context.Context, id int64) (*KeyProvider, error) {
	row := q.db.QueryRowContext(ctx, GetKeyProviderByID, id)
	var i KeyProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.IsDefault,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetKeysByFilter = `-- name: GetKeysByFilter :many
SELECT k.id, k.name, k.description, k.algorithm, k.key_size, k.curve, k.format, k.public_key, k.private_key, k.certificate, k.status, k.created_at, k.updated_at, k.expires_at, k.last_rotated_at, k.signing_key_id, k.sha256_fingerprint, k.sha1_fingerprint, k.provider_id, k.user_id, k.is_ca, k.ethereum_address, kp.name as provider_name, kp.type as provider_type
FROM keys k
JOIN key_providers kp ON k.provider_id = kp.id
WHERE (?1 = '' OR k.algorithm = ?2) 
  AND (?3 = 0 OR k.provider_id = ?4)
  AND (?5 = '' OR k.curve = ?6)
`

type GetKeysByFilterParams struct {
	AlgorithmFilter  interface{}    `json:"algorithmFilter"`
	Algorithm        string         `json:"algorithm"`
	ProviderIDFilter interface{}    `json:"providerIdFilter"`
	ProviderID       int64          `json:"providerId"`
	CurveFilter      interface{}    `json:"curveFilter"`
	Curve            sql.NullString `json:"curve"`
}

type GetKeysByFilterRow struct {
	ID                int64          `json:"id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Algorithm         string         `json:"algorithm"`
	KeySize           sql.NullInt64  `json:"keySize"`
	Curve             sql.NullString `json:"curve"`
	Format            string         `json:"format"`
	PublicKey         string         `json:"publicKey"`
	PrivateKey        string         `json:"privateKey"`
	Certificate       sql.NullString `json:"certificate"`
	Status            string         `json:"status"`
	CreatedAt         time.Time      `json:"createdAt"`
	UpdatedAt         time.Time      `json:"updatedAt"`
	ExpiresAt         sql.NullTime   `json:"expiresAt"`
	LastRotatedAt     sql.NullTime   `json:"lastRotatedAt"`
	SigningKeyID      sql.NullInt64  `json:"signingKeyId"`
	Sha256Fingerprint string         `json:"sha256Fingerprint"`
	Sha1Fingerprint   string         `json:"sha1Fingerprint"`
	ProviderID        int64          `json:"providerId"`
	UserID            int64          `json:"userId"`
	IsCa              int64          `json:"isCa"`
	EthereumAddress   sql.NullString `json:"ethereumAddress"`
	ProviderName      string         `json:"providerName"`
	ProviderType      string         `json:"providerType"`
}

func (q *Queries) GetKeysByFilter(ctx context.Context, arg *GetKeysByFilterParams) ([]*GetKeysByFilterRow, error) {
	rows, err := q.db.QueryContext(ctx, GetKeysByFilter,
		arg.AlgorithmFilter,
		arg.Algorithm,
		arg.ProviderIDFilter,
		arg.ProviderID,
		arg.CurveFilter,
		arg.Curve,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetKeysByFilterRow{}
	for rows.Next() {
		var i GetKeysByFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Algorithm,
			&i.KeySize,
			&i.Curve,
			&i.Format,
			&i.PublicKey,
			&i.PrivateKey,
			&i.Certificate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
			&i.LastRotatedAt,
			&i.SigningKeyID,
			&i.Sha256Fingerprint,
			&i.Sha1Fingerprint,
			&i.ProviderID,
			&i.UserID,
			&i.IsCa,
			&i.EthereumAddress,
			&i.ProviderName,
			&i.ProviderType,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetKeysCount = `-- name: GetKeysCount :one
SELECT COUNT(*) FROM keys
`

func (q *Queries) GetKeysCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetKeysCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetLatestNodeEvent = `-- name: GetLatestNodeEvent :one
SELECT id, node_id, event_type, description, data, status, created_at FROM node_events
WHERE node_id = ?
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestNodeEvent(ctx context.Context, nodeID int64) (*NodeEvent, error) {
	row := q.db.QueryRowContext(ctx, GetLatestNodeEvent, nodeID)
	var i NodeEvent
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.EventType,
		&i.Description,
		&i.Data,
		&i.Status,
		&i.CreatedAt,
	)
	return &i, err
}

const GetNetwork = `-- name: GetNetwork :one
SELECT id, name, network_id, platform, status, description, config, deployment_config, exposed_ports, domain, created_at, created_by, updated_at, genesis_block_b64, current_config_block_b64 FROM networks
WHERE id = ? LIMIT 1
`

func (q *Queries) GetNetwork(ctx context.Context, id int64) (*Network, error) {
	row := q.db.QueryRowContext(ctx, GetNetwork, id)
	var i Network
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NetworkID,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.Config,
		&i.DeploymentConfig,
		&i.ExposedPorts,
		&i.Domain,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.GenesisBlockB64,
		&i.CurrentConfigBlockB64,
	)
	return &i, err
}

const GetNetworkByName = `-- name: GetNetworkByName :one
SELECT id, name, network_id, platform, status, description, config, deployment_config, exposed_ports, domain, created_at, created_by, updated_at, genesis_block_b64, current_config_block_b64 FROM networks
WHERE name = ? LIMIT 1
`

func (q *Queries) GetNetworkByName(ctx context.Context, name string) (*Network, error) {
	row := q.db.QueryRowContext(ctx, GetNetworkByName, name)
	var i Network
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NetworkID,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.Config,
		&i.DeploymentConfig,
		&i.ExposedPorts,
		&i.Domain,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.GenesisBlockB64,
		&i.CurrentConfigBlockB64,
	)
	return &i, err
}

const GetNetworkByNetworkId = `-- name: GetNetworkByNetworkId :one
SELECT id, name, network_id, platform, status, description, config, deployment_config, exposed_ports, domain, created_at, created_by, updated_at, genesis_block_b64, current_config_block_b64 FROM networks
WHERE network_id = ? LIMIT 1
`

func (q *Queries) GetNetworkByNetworkId(ctx context.Context, networkID sql.NullString) (*Network, error) {
	row := q.db.QueryRowContext(ctx, GetNetworkByNetworkId, networkID)
	var i Network
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NetworkID,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.Config,
		&i.DeploymentConfig,
		&i.ExposedPorts,
		&i.Domain,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.GenesisBlockB64,
		&i.CurrentConfigBlockB64,
	)
	return &i, err
}

const GetNetworkCurrentConfigBlock = `-- name: GetNetworkCurrentConfigBlock :one
SELECT current_config_block_b64 FROM networks
WHERE id = ?
`

func (q *Queries) GetNetworkCurrentConfigBlock(ctx context.Context, id int64) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, GetNetworkCurrentConfigBlock, id)
	var current_config_block_b64 sql.NullString
	err := row.Scan(&current_config_block_b64)
	return current_config_block_b64, err
}

const GetNetworkNode = `-- name: GetNetworkNode :one
SELECT id, network_id, node_id, role, status, config, created_at, updated_at FROM network_nodes
WHERE network_id = ? AND node_id = ?
`

type GetNetworkNodeParams struct {
	NetworkID int64 `json:"networkId"`
	NodeID    int64 `json:"nodeId"`
}

func (q *Queries) GetNetworkNode(ctx context.Context, arg *GetNetworkNodeParams) (*NetworkNode, error) {
	row := q.db.QueryRowContext(ctx, GetNetworkNode, arg.NetworkID, arg.NodeID)
	var i NetworkNode
	err := row.Scan(
		&i.ID,
		&i.NetworkID,
		&i.NodeID,
		&i.Role,
		&i.Status,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetNetworkNodes = `-- name: GetNetworkNodes :many
SELECT nn.id, nn.network_id, nn.node_id, nn.role, nn.status, nn.config, nn.created_at, nn.updated_at, n.id, n.name, n.slug, n.platform, n.status, n.description, n.network_id, n.config, n.resources, n.endpoint, n.public_endpoint, n.p2p_address, n.created_at, n.created_by, n.updated_at, n.fabric_organization_id, n.node_type, n.node_config, n.deployment_config, n.error_message 
FROM network_nodes nn
JOIN nodes n ON nn.node_id = n.id
WHERE nn.network_id = ? 
ORDER BY nn.created_at DESC
`

type GetNetworkNodesRow struct {
	ID                   int64          `json:"id"`
	NetworkID            int64          `json:"networkId"`
	NodeID               int64          `json:"nodeId"`
	Role                 string         `json:"role"`
	Status               string         `json:"status"`
	Config               sql.NullString `json:"config"`
	CreatedAt            time.Time      `json:"createdAt"`
	UpdatedAt            time.Time      `json:"updatedAt"`
	ID_2                 int64          `json:"id2"`
	Name                 string         `json:"name"`
	Slug                 string         `json:"slug"`
	Platform             string         `json:"platform"`
	Status_2             string         `json:"status2"`
	Description          sql.NullString `json:"description"`
	NetworkID_2          sql.NullInt64  `json:"networkId2"`
	Config_2             sql.NullString `json:"config2"`
	Resources            sql.NullString `json:"resources"`
	Endpoint             sql.NullString `json:"endpoint"`
	PublicEndpoint       sql.NullString `json:"publicEndpoint"`
	P2pAddress           sql.NullString `json:"p2pAddress"`
	CreatedAt_2          time.Time      `json:"createdAt2"`
	CreatedBy            sql.NullInt64  `json:"createdBy"`
	UpdatedAt_2          sql.NullTime   `json:"updatedAt2"`
	FabricOrganizationID sql.NullInt64  `json:"fabricOrganizationId"`
	NodeType             sql.NullString `json:"nodeType"`
	NodeConfig           sql.NullString `json:"nodeConfig"`
	DeploymentConfig     sql.NullString `json:"deploymentConfig"`
	ErrorMessage         sql.NullString `json:"errorMessage"`
}

func (q *Queries) GetNetworkNodes(ctx context.Context, networkID int64) ([]*GetNetworkNodesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetNetworkNodes, networkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetNetworkNodesRow{}
	for rows.Next() {
		var i GetNetworkNodesRow
		if err := rows.Scan(
			&i.ID,
			&i.NetworkID,
			&i.NodeID,
			&i.Role,
			&i.Status,
			&i.Config,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Name,
			&i.Slug,
			&i.Platform,
			&i.Status_2,
			&i.Description,
			&i.NetworkID_2,
			&i.Config_2,
			&i.Resources,
			&i.Endpoint,
			&i.PublicEndpoint,
			&i.P2pAddress,
			&i.CreatedAt_2,
			&i.CreatedBy,
			&i.UpdatedAt_2,
			&i.FabricOrganizationID,
			&i.NodeType,
			&i.NodeConfig,
			&i.DeploymentConfig,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetNode = `-- name: GetNode :one
SELECT id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config, error_message FROM nodes
WHERE id = ? LIMIT 1
`

func (q *Queries) GetNode(ctx context.Context, id int64) (*Node, error) {
	row := q.db.QueryRowContext(ctx, GetNode, id)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.NetworkID,
		&i.Config,
		&i.Resources,
		&i.Endpoint,
		&i.PublicEndpoint,
		&i.P2pAddress,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.FabricOrganizationID,
		&i.NodeType,
		&i.NodeConfig,
		&i.DeploymentConfig,
		&i.ErrorMessage,
	)
	return &i, err
}

const GetNodeBySlug = `-- name: GetNodeBySlug :one
SELECT id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config, error_message FROM nodes WHERE slug = ?
`

func (q *Queries) GetNodeBySlug(ctx context.Context, slug string) (*Node, error) {
	row := q.db.QueryRowContext(ctx, GetNodeBySlug, slug)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.NetworkID,
		&i.Config,
		&i.Resources,
		&i.Endpoint,
		&i.PublicEndpoint,
		&i.P2pAddress,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.FabricOrganizationID,
		&i.NodeType,
		&i.NodeConfig,
		&i.DeploymentConfig,
		&i.ErrorMessage,
	)
	return &i, err
}

const GetNodeEvent = `-- name: GetNodeEvent :one
SELECT id, node_id, event_type, description, data, status, created_at FROM node_events
WHERE id = ? LIMIT 1
`

func (q *Queries) GetNodeEvent(ctx context.Context, id int64) (*NodeEvent, error) {
	row := q.db.QueryRowContext(ctx, GetNodeEvent, id)
	var i NodeEvent
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.EventType,
		&i.Description,
		&i.Data,
		&i.Status,
		&i.CreatedAt,
	)
	return &i, err
}

const GetNotificationProvider = `-- name: GetNotificationProvider :one
SELECT id, name, type, config, is_default, is_enabled, created_at, updated_at, notify_node_downtime, notify_backup_success, notify_backup_failure, notify_s3_connection_issue, last_test_at, last_test_status, last_test_message FROM notification_providers
WHERE id = ? LIMIT 1
`

func (q *Queries) GetNotificationProvider(ctx context.Context, id int64) (*NotificationProvider, error) {
	row := q.db.QueryRowContext(ctx, GetNotificationProvider, id)
	var i NotificationProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Config,
		&i.IsDefault,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotifyNodeDowntime,
		&i.NotifyBackupSuccess,
		&i.NotifyBackupFailure,
		&i.NotifyS3ConnectionIssue,
		&i.LastTestAt,
		&i.LastTestStatus,
		&i.LastTestMessage,
	)
	return &i, err
}

const GetOldestBackupByTarget = `-- name: GetOldestBackupByTarget :one
SELECT id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent FROM backups
WHERE target_id = ?
ORDER BY created_at ASC
LIMIT 1
`

func (q *Queries) GetOldestBackupByTarget(ctx context.Context, targetID int64) (*Backup, error) {
	row := q.db.QueryRowContext(ctx, GetOldestBackupByTarget, targetID)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.ScheduleID,
		&i.TargetID,
		&i.Status,
		&i.SizeBytes,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.NotificationSent,
	)
	return &i, err
}

const GetOrdererPorts = `-- name: GetOrdererPorts :many
SELECT endpoint, public_endpoint
FROM nodes
WHERE node_type = 'fabric-orderer'
AND (endpoint IS NOT NULL OR public_endpoint IS NOT NULL)
`

type GetOrdererPortsRow struct {
	Endpoint       sql.NullString `json:"endpoint"`
	PublicEndpoint sql.NullString `json:"publicEndpoint"`
}

func (q *Queries) GetOrdererPorts(ctx context.Context) ([]*GetOrdererPortsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetOrdererPorts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetOrdererPortsRow{}
	for rows.Next() {
		var i GetOrdererPortsRow
		if err := rows.Scan(&i.Endpoint, &i.PublicEndpoint); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetOrganizationCRLInfo = `-- name: GetOrganizationCRLInfo :one
SELECT crl_key_id, crl_last_update
FROM fabric_organizations
WHERE id = ?
`

type GetOrganizationCRLInfoRow struct {
	CrlKeyID      sql.NullInt64 `json:"crlKeyId"`
	CrlLastUpdate sql.NullTime  `json:"crlLastUpdate"`
}

func (q *Queries) GetOrganizationCRLInfo(ctx context.Context, id int64) (*GetOrganizationCRLInfoRow, error) {
	row := q.db.QueryRowContext(ctx, GetOrganizationCRLInfo, id)
	var i GetOrganizationCRLInfoRow
	err := row.Scan(&i.CrlKeyID, &i.CrlLastUpdate)
	return &i, err
}

const GetPeerPorts = `-- name: GetPeerPorts :many
SELECT endpoint, public_endpoint
FROM nodes
WHERE node_type = 'fabric-peer'
AND (endpoint IS NOT NULL OR public_endpoint IS NOT NULL)
`

type GetPeerPortsRow struct {
	Endpoint       sql.NullString `json:"endpoint"`
	PublicEndpoint sql.NullString `json:"publicEndpoint"`
}

func (q *Queries) GetPeerPorts(ctx context.Context) ([]*GetPeerPortsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetPeerPorts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPeerPortsRow{}
	for rows.Next() {
		var i GetPeerPortsRow
		if err := rows.Scan(&i.Endpoint, &i.PublicEndpoint); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPlugin = `-- name: GetPlugin :one
SELECT name, api_version, kind, metadata, spec, created_at, updated_at, deployment_metadata, deployment_status FROM plugins WHERE name = ?
`

func (q *Queries) GetPlugin(ctx context.Context, name string) (*Plugin, error) {
	row := q.db.QueryRowContext(ctx, GetPlugin, name)
	var i Plugin
	err := row.Scan(
		&i.Name,
		&i.ApiVersion,
		&i.Kind,
		&i.Metadata,
		&i.Spec,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeploymentMetadata,
		&i.DeploymentStatus,
	)
	return &i, err
}

const GetPrometheusConfig = `-- name: GetPrometheusConfig :one
SELECT id, prometheus_port, data_dir, config_dir, container_name, scrape_interval, evaluation_interval, deployment_mode, docker_image, docker_network, docker_restart_policy, docker_extra_args, created_at, updated_at FROM prometheus_config
WHERE id = 1
`

func (q *Queries) GetPrometheusConfig(ctx context.Context) (*PrometheusConfig, error) {
	row := q.db.QueryRowContext(ctx, GetPrometheusConfig)
	var i PrometheusConfig
	err := row.Scan(
		&i.ID,
		&i.PrometheusPort,
		&i.DataDir,
		&i.ConfigDir,
		&i.ContainerName,
		&i.ScrapeInterval,
		&i.EvaluationInterval,
		&i.DeploymentMode,
		&i.DockerImage,
		&i.DockerNetwork,
		&i.DockerRestartPolicy,
		&i.DockerExtraArgs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetProvidersByNotificationType = `-- name: GetProvidersByNotificationType :many
SELECT id, name, type, config, is_default, is_enabled, created_at, updated_at, notify_node_downtime, notify_backup_success, notify_backup_failure, notify_s3_connection_issue, last_test_at, last_test_status, last_test_message FROM notification_providers
WHERE (
    (? = 'NODE_DOWNTIME' AND notify_node_downtime = 1) OR
    (? = 'BACKUP_SUCCESS' AND notify_backup_success = 1) OR
    (? = 'BACKUP_FAILURE' AND notify_backup_failure = 1) OR
    (? = 'S3_CONNECTION_ISSUE' AND notify_s3_connection_issue = 1)
)
ORDER BY created_at DESC
`

type GetProvidersByNotificationTypeParams struct {
	Column1 interface{} `json:"column1"`
	Column2 interface{} `json:"column2"`
	Column3 interface{} `json:"column3"`
	Column4 interface{} `json:"column4"`
}

func (q *Queries) GetProvidersByNotificationType(ctx context.Context, arg *GetProvidersByNotificationTypeParams) ([]*NotificationProvider, error) {
	rows, err := q.db.QueryContext(ctx, GetProvidersByNotificationType,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*NotificationProvider{}
	for rows.Next() {
		var i NotificationProvider
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Config,
			&i.IsDefault,
			&i.IsEnabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NotifyNodeDowntime,
			&i.NotifyBackupSuccess,
			&i.NotifyBackupFailure,
			&i.NotifyS3ConnectionIssue,
			&i.LastTestAt,
			&i.LastTestStatus,
			&i.LastTestMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRecentCompletedBackups = `-- name: GetRecentCompletedBackups :many
SELECT id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent FROM backups
WHERE (status = 'COMPLETED' OR status = 'FAILED')
  AND notification_sent = false
ORDER BY completed_at DESC
LIMIT 50
`

func (q *Queries) GetRecentCompletedBackups(ctx context.Context) ([]*Backup, error) {
	rows, err := q.db.QueryContext(ctx, GetRecentCompletedBackups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Backup{}
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.ID,
			&i.ScheduleID,
			&i.TargetID,
			&i.Status,
			&i.SizeBytes,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.NotificationSent,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRevokedCertificate = `-- name: GetRevokedCertificate :one
SELECT id, fabric_organization_id, serial_number, revocation_time, reason, issuer_certificate_id, created_at, updated_at FROM fabric_revoked_certificates
WHERE fabric_organization_id = ? AND serial_number = ?
`

type GetRevokedCertificateParams struct {
	FabricOrganizationID int64  `json:"fabricOrganizationId"`
	SerialNumber         string `json:"serialNumber"`
}

func (q *Queries) GetRevokedCertificate(ctx context.Context, arg *GetRevokedCertificateParams) (*FabricRevokedCertificate, error) {
	row := q.db.QueryRowContext(ctx, GetRevokedCertificate, arg.FabricOrganizationID, arg.SerialNumber)
	var i FabricRevokedCertificate
	err := row.Scan(
		&i.ID,
		&i.FabricOrganizationID,
		&i.SerialNumber,
		&i.RevocationTime,
		&i.Reason,
		&i.IssuerCertificateID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetRevokedCertificateCount = `-- name: GetRevokedCertificateCount :one
SELECT COUNT(*) FROM fabric_revoked_certificates
WHERE fabric_organization_id = ?
`

func (q *Queries) GetRevokedCertificateCount(ctx context.Context, fabricOrganizationID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetRevokedCertificateCount, fabricOrganizationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetRevokedCertificates = `-- name: GetRevokedCertificates :many
SELECT id, fabric_organization_id, serial_number, revocation_time, reason, issuer_certificate_id, created_at, updated_at FROM fabric_revoked_certificates
WHERE fabric_organization_id = ?
ORDER BY revocation_time DESC
`

func (q *Queries) GetRevokedCertificates(ctx context.Context, fabricOrganizationID int64) ([]*FabricRevokedCertificate, error) {
	rows, err := q.db.QueryContext(ctx, GetRevokedCertificates, fabricOrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*FabricRevokedCertificate{}
	for rows.Next() {
		var i FabricRevokedCertificate
		if err := rows.Scan(
			&i.ID,
			&i.FabricOrganizationID,
			&i.SerialNumber,
			&i.RevocationTime,
			&i.Reason,
			&i.IssuerCertificateID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSession = `-- name: GetSession :one
SELECT id, session_id, user_id, token, ip_address, user_agent, created_at, updated_at, expires_at, last_activity_at FROM sessions WHERE token = ? LIMIT 1
`

func (q *Queries) GetSession(ctx context.Context, token string) (*Session, error) {
	row := q.db.QueryRowContext(ctx, GetSession, token)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.UserID,
		&i.Token,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.LastActivityAt,
	)
	return &i, err
}

const GetSessionBySessionID = `-- name: GetSessionBySessionID :one
SELECT id, session_id, user_id, token, ip_address, user_agent, created_at, updated_at, expires_at, last_activity_at FROM sessions
WHERE session_id = ?
`

func (q *Queries) GetSessionBySessionID(ctx context.Context, sessionID string) (*Session, error) {
	row := q.db.QueryRowContext(ctx, GetSessionBySessionID, sessionID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.UserID,
		&i.Token,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.LastActivityAt,
	)
	return &i, err
}

const GetSessionByToken = `-- name: GetSessionByToken :one
SELECT id, session_id, user_id, token, ip_address, user_agent, created_at, updated_at, expires_at, last_activity_at FROM sessions
WHERE token = ?
`

func (q *Queries) GetSessionByToken(ctx context.Context, token string) (*Session, error) {
	row := q.db.QueryRowContext(ctx, GetSessionByToken, token)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.UserID,
		&i.Token,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.LastActivityAt,
	)
	return &i, err
}

const GetSetting = `-- name: GetSetting :one
SELECT id, config, created_at, updated_at FROM settings
WHERE id = ? LIMIT 1
`

func (q *Queries) GetSetting(ctx context.Context, id int64) (*Setting, error) {
	row := q.db.QueryRowContext(ctx, GetSetting, id)
	var i Setting
	err := row.Scan(
		&i.ID,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetUser = `-- name: GetUser :one
SELECT id, username, password, name, email, role, provider, provider_id, avatar_url, created_at, last_login_at, updated_at FROM users
WHERE id = ? LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id int64) (*User, error) {
	row := q.db.QueryRowContext(ctx, GetUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Name,
		&i.Email,
		&i.Role,
		&i.Provider,
		&i.ProviderID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.LastLoginAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, password, name, email, role, provider, provider_id, avatar_url, created_at, last_login_at, updated_at FROM users
WHERE username = ? LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (*User, error) {
	row := q.db.QueryRowContext(ctx, GetUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Name,
		&i.Email,
		&i.Role,
		&i.Provider,
		&i.ProviderID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.LastLoginAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const ListAuditLogs = `-- name: ListAuditLogs :many
SELECT id, timestamp, event_source, user_identity, source_ip, event_type, event_outcome, affected_resource, request_id, severity, details, created_at, updated_at FROM audit_logs
WHERE (? IS NULL OR timestamp >= ?)
  AND (? IS NULL OR timestamp <= ?)
  AND (? = '' OR event_type = ?)
  AND (? = 0 OR user_identity = ?)
ORDER BY timestamp DESC
LIMIT ? OFFSET ?
`

type ListAuditLogsParams struct {
	Column1      interface{} `json:"column1"`
	Timestamp    time.Time   `json:"timestamp"`
	Column3      interface{} `json:"column3"`
	Timestamp_2  time.Time   `json:"timestamp2"`
	Column5      interface{} `json:"column5"`
	EventType    string      `json:"eventType"`
	Column7      interface{} `json:"column7"`
	UserIdentity int64       `json:"userIdentity"`
	Limit        int64       `json:"limit"`
	Offset       int64       `json:"offset"`
}

func (q *Queries) ListAuditLogs(ctx context.Context, arg *ListAuditLogsParams) ([]*AuditLog, error) {
	rows, err := q.db.QueryContext(ctx, ListAuditLogs,
		arg.Column1,
		arg.Timestamp,
		arg.Column3,
		arg.Timestamp_2,
		arg.Column5,
		arg.EventType,
		arg.Column7,
		arg.UserIdentity,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.EventSource,
			&i.UserIdentity,
			&i.SourceIp,
			&i.EventType,
			&i.EventOutcome,
			&i.AffectedResource,
			&i.RequestID,
			&i.Severity,
			&i.Details,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListBackupSchedules = `-- name: ListBackupSchedules :many
SELECT id, name, description, cron_expression, target_id, retention_days, enabled, created_at, updated_at, last_run_at, next_run_at FROM backup_schedules
ORDER BY created_at DESC
`

func (q *Queries) ListBackupSchedules(ctx context.Context) ([]*BackupSchedule, error) {
	rows, err := q.db.QueryContext(ctx, ListBackupSchedules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*BackupSchedule{}
	for rows.Next() {
		var i BackupSchedule
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CronExpression,
			&i.TargetID,
			&i.RetentionDays,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastRunAt,
			&i.NextRunAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListBackupTargets = `-- name: ListBackupTargets :many
SELECT id, name, bucket_name, region, endpoint, bucket_path, access_key_id, secret_key, s3_path_style, restic_password, type, created_at, updated_at FROM backup_targets
ORDER BY created_at DESC
`

func (q *Queries) ListBackupTargets(ctx context.Context) ([]*BackupTarget, error) {
	rows, err := q.db.QueryContext(ctx, ListBackupTargets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*BackupTarget{}
	for rows.Next() {
		var i BackupTarget
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BucketName,
			&i.Region,
			&i.Endpoint,
			&i.BucketPath,
			&i.AccessKeyID,
			&i.SecretKey,
			&i.S3PathStyle,
			&i.ResticPassword,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListBackups = `-- name: ListBackups :many
SELECT id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent FROM backups
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListBackupsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListBackups(ctx context.Context, arg *ListBackupsParams) ([]*Backup, error) {
	rows, err := q.db.QueryContext(ctx, ListBackups, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Backup{}
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.ID,
			&i.ScheduleID,
			&i.TargetID,
			&i.Status,
			&i.SizeBytes,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.NotificationSent,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListBackupsBySchedule = `-- name: ListBackupsBySchedule :many
SELECT id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent FROM backups
WHERE schedule_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListBackupsBySchedule(ctx context.Context, scheduleID sql.NullInt64) ([]*Backup, error) {
	rows, err := q.db.QueryContext(ctx, ListBackupsBySchedule, scheduleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Backup{}
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.ID,
			&i.ScheduleID,
			&i.TargetID,
			&i.Status,
			&i.SizeBytes,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.NotificationSent,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListBackupsByTarget = `-- name: ListBackupsByTarget :many
SELECT id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent FROM backups
WHERE target_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListBackupsByTarget(ctx context.Context, targetID int64) ([]*Backup, error) {
	rows, err := q.db.QueryContext(ctx, ListBackupsByTarget, targetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Backup{}
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.ID,
			&i.ScheduleID,
			&i.TargetID,
			&i.Status,
			&i.SizeBytes,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.NotificationSent,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListFabricOrganizations = `-- name: ListFabricOrganizations :many
SELECT id, msp_id, description, config, ca_config, sign_key_id, tls_root_key_id, admin_tls_key_id, admin_sign_key_id, client_sign_key_id, provider_id, created_at, created_by, updated_at, crl_key_id, crl_last_update FROM fabric_organizations
ORDER BY created_at DESC
`

func (q *Queries) ListFabricOrganizations(ctx context.Context) ([]*FabricOrganization, error) {
	rows, err := q.db.QueryContext(ctx, ListFabricOrganizations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*FabricOrganization{}
	for rows.Next() {
		var i FabricOrganization
		if err := rows.Scan(
			&i.ID,
			&i.MspID,
			&i.Description,
			&i.Config,
			&i.CaConfig,
			&i.SignKeyID,
			&i.TlsRootKeyID,
			&i.AdminTlsKeyID,
			&i.AdminSignKeyID,
			&i.ClientSignKeyID,
			&i.ProviderID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.CrlKeyID,
			&i.CrlLastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListFabricOrganizationsWithKeys = `-- name: ListFabricOrganizationsWithKeys :many
SELECT 
    fo.id, fo.msp_id, fo.description, fo.config, fo.ca_config, fo.sign_key_id, fo.tls_root_key_id, fo.admin_tls_key_id, fo.admin_sign_key_id, fo.client_sign_key_id, fo.provider_id, fo.created_at, fo.created_by, fo.updated_at, fo.crl_key_id, fo.crl_last_update,
    sk.public_key as sign_public_key,
    sk.certificate as sign_certificate,
    tk.public_key as tls_public_key,
    tk.certificate as tls_certificate,
    p.name as provider_name
FROM fabric_organizations fo
LEFT JOIN keys sk ON fo.sign_key_id = sk.id
LEFT JOIN keys tk ON fo.tls_root_key_id = tk.id
LEFT JOIN key_providers p ON fo.provider_id = p.id
ORDER BY fo.created_at DESC
`

type ListFabricOrganizationsWithKeysRow struct {
	ID              int64          `json:"id"`
	MspID           string         `json:"mspId"`
	Description     sql.NullString `json:"description"`
	Config          sql.NullString `json:"config"`
	CaConfig        sql.NullString `json:"caConfig"`
	SignKeyID       sql.NullInt64  `json:"signKeyId"`
	TlsRootKeyID    sql.NullInt64  `json:"tlsRootKeyId"`
	AdminTlsKeyID   sql.NullInt64  `json:"adminTlsKeyId"`
	AdminSignKeyID  sql.NullInt64  `json:"adminSignKeyId"`
	ClientSignKeyID sql.NullInt64  `json:"clientSignKeyId"`
	ProviderID      sql.NullInt64  `json:"providerId"`
	CreatedAt       time.Time      `json:"createdAt"`
	CreatedBy       sql.NullInt64  `json:"createdBy"`
	UpdatedAt       sql.NullTime   `json:"updatedAt"`
	CrlKeyID        sql.NullInt64  `json:"crlKeyId"`
	CrlLastUpdate   sql.NullTime   `json:"crlLastUpdate"`
	SignPublicKey   sql.NullString `json:"signPublicKey"`
	SignCertificate sql.NullString `json:"signCertificate"`
	TlsPublicKey    sql.NullString `json:"tlsPublicKey"`
	TlsCertificate  sql.NullString `json:"tlsCertificate"`
	ProviderName    sql.NullString `json:"providerName"`
}

func (q *Queries) ListFabricOrganizationsWithKeys(ctx context.Context) ([]*ListFabricOrganizationsWithKeysRow, error) {
	rows, err := q.db.QueryContext(ctx, ListFabricOrganizationsWithKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListFabricOrganizationsWithKeysRow{}
	for rows.Next() {
		var i ListFabricOrganizationsWithKeysRow
		if err := rows.Scan(
			&i.ID,
			&i.MspID,
			&i.Description,
			&i.Config,
			&i.CaConfig,
			&i.SignKeyID,
			&i.TlsRootKeyID,
			&i.AdminTlsKeyID,
			&i.AdminSignKeyID,
			&i.ClientSignKeyID,
			&i.ProviderID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.CrlKeyID,
			&i.CrlLastUpdate,
			&i.SignPublicKey,
			&i.SignCertificate,
			&i.TlsPublicKey,
			&i.TlsCertificate,
			&i.ProviderName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListKeyProviders = `-- name: ListKeyProviders :many
SELECT id, name, type, is_default, config, created_at, updated_at FROM key_providers
`

func (q *Queries) ListKeyProviders(ctx context.Context) ([]*KeyProvider, error) {
	rows, err := q.db.QueryContext(ctx, ListKeyProviders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*KeyProvider{}
	for rows.Next() {
		var i KeyProvider
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.IsDefault,
			&i.Config,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListKeys = `-- name: ListKeys :many
SELECT k.id, k.name, k.description, k.algorithm, k.key_size, k.curve, k.format, k.public_key, k.private_key, k.certificate, k.status, k.created_at, k.updated_at, k.expires_at, k.last_rotated_at, k.signing_key_id, k.sha256_fingerprint, k.sha1_fingerprint, k.provider_id, k.user_id, k.is_ca, k.ethereum_address, kp.name as provider_name, kp.type as provider_type
FROM keys k
JOIN key_providers kp ON k.provider_id = kp.id
ORDER BY k.created_at DESC
LIMIT ? OFFSET ?
`

type ListKeysParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListKeysRow struct {
	ID                int64          `json:"id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Algorithm         string         `json:"algorithm"`
	KeySize           sql.NullInt64  `json:"keySize"`
	Curve             sql.NullString `json:"curve"`
	Format            string         `json:"format"`
	PublicKey         string         `json:"publicKey"`
	PrivateKey        string         `json:"privateKey"`
	Certificate       sql.NullString `json:"certificate"`
	Status            string         `json:"status"`
	CreatedAt         time.Time      `json:"createdAt"`
	UpdatedAt         time.Time      `json:"updatedAt"`
	ExpiresAt         sql.NullTime   `json:"expiresAt"`
	LastRotatedAt     sql.NullTime   `json:"lastRotatedAt"`
	SigningKeyID      sql.NullInt64  `json:"signingKeyId"`
	Sha256Fingerprint string         `json:"sha256Fingerprint"`
	Sha1Fingerprint   string         `json:"sha1Fingerprint"`
	ProviderID        int64          `json:"providerId"`
	UserID            int64          `json:"userId"`
	IsCa              int64          `json:"isCa"`
	EthereumAddress   sql.NullString `json:"ethereumAddress"`
	ProviderName      string         `json:"providerName"`
	ProviderType      string         `json:"providerType"`
}

func (q *Queries) ListKeys(ctx context.Context, arg *ListKeysParams) ([]*ListKeysRow, error) {
	rows, err := q.db.QueryContext(ctx, ListKeys, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListKeysRow{}
	for rows.Next() {
		var i ListKeysRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Algorithm,
			&i.KeySize,
			&i.Curve,
			&i.Format,
			&i.PublicKey,
			&i.PrivateKey,
			&i.Certificate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
			&i.LastRotatedAt,
			&i.SigningKeyID,
			&i.Sha256Fingerprint,
			&i.Sha1Fingerprint,
			&i.ProviderID,
			&i.UserID,
			&i.IsCa,
			&i.EthereumAddress,
			&i.ProviderName,
			&i.ProviderType,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListNetworkNodesByNetwork = `-- name: ListNetworkNodesByNetwork :many
SELECT id, network_id, node_id, role, status, config, created_at, updated_at FROM network_nodes
WHERE network_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListNetworkNodesByNetwork(ctx context.Context, networkID int64) ([]*NetworkNode, error) {
	rows, err := q.db.QueryContext(ctx, ListNetworkNodesByNetwork, networkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*NetworkNode{}
	for rows.Next() {
		var i NetworkNode
		if err := rows.Scan(
			&i.ID,
			&i.NetworkID,
			&i.NodeID,
			&i.Role,
			&i.Status,
			&i.Config,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListNetworkNodesByNode = `-- name: ListNetworkNodesByNode :many
SELECT id, network_id, node_id, role, status, config, created_at, updated_at FROM network_nodes
WHERE node_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListNetworkNodesByNode(ctx context.Context, nodeID int64) ([]*NetworkNode, error) {
	rows, err := q.db.QueryContext(ctx, ListNetworkNodesByNode, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*NetworkNode{}
	for rows.Next() {
		var i NetworkNode
		if err := rows.Scan(
			&i.ID,
			&i.NetworkID,
			&i.NodeID,
			&i.Role,
			&i.Status,
			&i.Config,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListNetworks = `-- name: ListNetworks :many
SELECT id, name, network_id, platform, status, description, config, deployment_config, exposed_ports, domain, created_at, created_by, updated_at, genesis_block_b64, current_config_block_b64 FROM networks
ORDER BY created_at DESC
`

func (q *Queries) ListNetworks(ctx context.Context) ([]*Network, error) {
	rows, err := q.db.QueryContext(ctx, ListNetworks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Network{}
	for rows.Next() {
		var i Network
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.NetworkID,
			&i.Platform,
			&i.Status,
			&i.Description,
			&i.Config,
			&i.DeploymentConfig,
			&i.ExposedPorts,
			&i.Domain,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.GenesisBlockB64,
			&i.CurrentConfigBlockB64,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListNodeEvents = `-- name: ListNodeEvents :many
SELECT id, node_id, event_type, description, data, status, created_at FROM node_events
WHERE node_id = ?
ORDER BY id DESC
LIMIT ? OFFSET ?
`

type ListNodeEventsParams struct {
	NodeID int64 `json:"nodeId"`
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListNodeEvents(ctx context.Context, arg *ListNodeEventsParams) ([]*NodeEvent, error) {
	rows, err := q.db.QueryContext(ctx, ListNodeEvents, arg.NodeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*NodeEvent{}
	for rows.Next() {
		var i NodeEvent
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.EventType,
			&i.Description,
			&i.Data,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListNodeEventsByType = `-- name: ListNodeEventsByType :many
SELECT id, node_id, event_type, description, data, status, created_at FROM node_events
WHERE node_id = ? AND event_type = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListNodeEventsByTypeParams struct {
	NodeID    int64  `json:"nodeId"`
	EventType string `json:"eventType"`
	Limit     int64  `json:"limit"`
	Offset    int64  `json:"offset"`
}

func (q *Queries) ListNodeEventsByType(ctx context.Context, arg *ListNodeEventsByTypeParams) ([]*NodeEvent, error) {
	rows, err := q.db.QueryContext(ctx, ListNodeEventsByType,
		arg.NodeID,
		arg.EventType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*NodeEvent{}
	for rows.Next() {
		var i NodeEvent
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.EventType,
			&i.Description,
			&i.Data,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListNodes = `-- name: ListNodes :many
SELECT id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config, error_message FROM nodes
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListNodesParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListNodes(ctx context.Context, arg *ListNodesParams) ([]*Node, error) {
	rows, err := q.db.QueryContext(ctx, ListNodes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Platform,
			&i.Status,
			&i.Description,
			&i.NetworkID,
			&i.Config,
			&i.Resources,
			&i.Endpoint,
			&i.PublicEndpoint,
			&i.P2pAddress,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.FabricOrganizationID,
			&i.NodeType,
			&i.NodeConfig,
			&i.DeploymentConfig,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListNodesByNetwork = `-- name: ListNodesByNetwork :many
SELECT id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config, error_message FROM nodes
WHERE network_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListNodesByNetworkParams struct {
	NetworkID sql.NullInt64 `json:"networkId"`
	Limit     int64         `json:"limit"`
	Offset    int64         `json:"offset"`
}

func (q *Queries) ListNodesByNetwork(ctx context.Context, arg *ListNodesByNetworkParams) ([]*Node, error) {
	rows, err := q.db.QueryContext(ctx, ListNodesByNetwork, arg.NetworkID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Platform,
			&i.Status,
			&i.Description,
			&i.NetworkID,
			&i.Config,
			&i.Resources,
			&i.Endpoint,
			&i.PublicEndpoint,
			&i.P2pAddress,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.FabricOrganizationID,
			&i.NodeType,
			&i.NodeConfig,
			&i.DeploymentConfig,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListNodesByPlatform = `-- name: ListNodesByPlatform :many
SELECT id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config, error_message FROM nodes
WHERE platform = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListNodesByPlatformParams struct {
	Platform string `json:"platform"`
	Limit    int64  `json:"limit"`
	Offset   int64  `json:"offset"`
}

func (q *Queries) ListNodesByPlatform(ctx context.Context, arg *ListNodesByPlatformParams) ([]*Node, error) {
	rows, err := q.db.QueryContext(ctx, ListNodesByPlatform, arg.Platform, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Platform,
			&i.Status,
			&i.Description,
			&i.NetworkID,
			&i.Config,
			&i.Resources,
			&i.Endpoint,
			&i.PublicEndpoint,
			&i.P2pAddress,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.FabricOrganizationID,
			&i.NodeType,
			&i.NodeConfig,
			&i.DeploymentConfig,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListNotificationProviders = `-- name: ListNotificationProviders :many
SELECT id, name, type, config, is_default, is_enabled, created_at, updated_at, notify_node_downtime, notify_backup_success, notify_backup_failure, notify_s3_connection_issue, last_test_at, last_test_status, last_test_message FROM notification_providers
ORDER BY created_at DESC
`

func (q *Queries) ListNotificationProviders(ctx context.Context) ([]*NotificationProvider, error) {
	rows, err := q.db.QueryContext(ctx, ListNotificationProviders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*NotificationProvider{}
	for rows.Next() {
		var i NotificationProvider
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Config,
			&i.IsDefault,
			&i.IsEnabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NotifyNodeDowntime,
			&i.NotifyBackupSuccess,
			&i.NotifyBackupFailure,
			&i.NotifyS3ConnectionIssue,
			&i.LastTestAt,
			&i.LastTestStatus,
			&i.LastTestMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPlugins = `-- name: ListPlugins :many
SELECT name, api_version, kind, metadata, spec, created_at, updated_at, deployment_metadata, deployment_status FROM plugins ORDER BY name
`

func (q *Queries) ListPlugins(ctx context.Context) ([]*Plugin, error) {
	rows, err := q.db.QueryContext(ctx, ListPlugins)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Plugin{}
	for rows.Next() {
		var i Plugin
		if err := rows.Scan(
			&i.Name,
			&i.ApiVersion,
			&i.Kind,
			&i.Metadata,
			&i.Spec,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeploymentMetadata,
			&i.DeploymentStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSettings = `-- name: ListSettings :many
SELECT id, config, created_at, updated_at FROM settings
ORDER BY created_at DESC
`

func (q *Queries) ListSettings(ctx context.Context) ([]*Setting, error) {
	rows, err := q.db.QueryContext(ctx, ListSettings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Setting{}
	for rows.Next() {
		var i Setting
		if err := rows.Scan(
			&i.ID,
			&i.Config,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListUsers = `-- name: ListUsers :many
SELECT id, username, password, name, email, role, provider, provider_id, avatar_url, created_at, last_login_at, updated_at FROM users
ORDER BY created_at DESC
`

func (q *Queries) ListUsers(ctx context.Context) ([]*User, error) {
	rows, err := q.db.QueryContext(ctx, ListUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Password,
			&i.Name,
			&i.Email,
			&i.Role,
			&i.Provider,
			&i.ProviderID,
			&i.AvatarUrl,
			&i.CreatedAt,
			&i.LastLoginAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const MarkBackupNotified = `-- name: MarkBackupNotified :exec
UPDATE backups
SET notification_sent = true
WHERE id = ?
`

func (q *Queries) MarkBackupNotified(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, MarkBackupNotified, id)
	return err
}

const ResetPrometheusConfig = `-- name: ResetPrometheusConfig :one
UPDATE prometheus_config
SET prometheus_port = 9090,
    data_dir = '/var/lib/prometheus',
    config_dir = '/etc/prometheus',
    container_name = 'chainlaunch-prometheus',
    scrape_interval = 15,
    evaluation_interval = 15,
    deployment_mode = 'docker',
    docker_image = 'prom/prometheus:latest',
    docker_network = 'chainlaunch-network',
    docker_restart_policy = 'unless-stopped',
    docker_extra_args = '--web.enable-lifecycle --web.enable-admin-api',
    updated_at = CURRENT_TIMESTAMP
WHERE id = 1
RETURNING id, prometheus_port, data_dir, config_dir, container_name, scrape_interval, evaluation_interval, deployment_mode, docker_image, docker_network, docker_restart_policy, docker_extra_args, created_at, updated_at
`

func (q *Queries) ResetPrometheusConfig(ctx context.Context) (*PrometheusConfig, error) {
	row := q.db.QueryRowContext(ctx, ResetPrometheusConfig)
	var i PrometheusConfig
	err := row.Scan(
		&i.ID,
		&i.PrometheusPort,
		&i.DataDir,
		&i.ConfigDir,
		&i.ContainerName,
		&i.ScrapeInterval,
		&i.EvaluationInterval,
		&i.DeploymentMode,
		&i.DockerImage,
		&i.DockerNetwork,
		&i.DockerRestartPolicy,
		&i.DockerExtraArgs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UnsetDefaultNotificationProvider = `-- name: UnsetDefaultNotificationProvider :exec
UPDATE notification_providers
SET is_default = 0,
    updated_at = CURRENT_TIMESTAMP
WHERE type = ? AND is_default = 1
`

func (q *Queries) UnsetDefaultNotificationProvider(ctx context.Context, type_ string) error {
	_, err := q.db.ExecContext(ctx, UnsetDefaultNotificationProvider, type_)
	return err
}

const UnsetDefaultProvider = `-- name: UnsetDefaultProvider :exec
UPDATE key_providers SET is_default = 0 WHERE is_default = 1
`

func (q *Queries) UnsetDefaultProvider(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, UnsetDefaultProvider)
	return err
}

const UpdateBackupCompleted = `-- name: UpdateBackupCompleted :one
UPDATE backups
SET status = ?,
    completed_at = ?
WHERE id = ?
RETURNING id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent
`

type UpdateBackupCompletedParams struct {
	Status      string       `json:"status"`
	CompletedAt sql.NullTime `json:"completedAt"`
	ID          int64        `json:"id"`
}

func (q *Queries) UpdateBackupCompleted(ctx context.Context, arg *UpdateBackupCompletedParams) (*Backup, error) {
	row := q.db.QueryRowContext(ctx, UpdateBackupCompleted, arg.Status, arg.CompletedAt, arg.ID)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.ScheduleID,
		&i.TargetID,
		&i.Status,
		&i.SizeBytes,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.NotificationSent,
	)
	return &i, err
}

const UpdateBackupFailed = `-- name: UpdateBackupFailed :one
UPDATE backups
SET status = ?,
    error_message = ?,
    completed_at = ?
WHERE id = ?
RETURNING id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent
`

type UpdateBackupFailedParams struct {
	Status       string         `json:"status"`
	ErrorMessage sql.NullString `json:"errorMessage"`
	CompletedAt  sql.NullTime   `json:"completedAt"`
	ID           int64          `json:"id"`
}

func (q *Queries) UpdateBackupFailed(ctx context.Context, arg *UpdateBackupFailedParams) (*Backup, error) {
	row := q.db.QueryRowContext(ctx, UpdateBackupFailed,
		arg.Status,
		arg.ErrorMessage,
		arg.CompletedAt,
		arg.ID,
	)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.ScheduleID,
		&i.TargetID,
		&i.Status,
		&i.SizeBytes,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.NotificationSent,
	)
	return &i, err
}

const UpdateBackupSchedule = `-- name: UpdateBackupSchedule :one
UPDATE backup_schedules
SET name = ?,
    description = ?,
    cron_expression = ?,
    target_id = ?,
    retention_days = ?,
    enabled = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, description, cron_expression, target_id, retention_days, enabled, created_at, updated_at, last_run_at, next_run_at
`

type UpdateBackupScheduleParams struct {
	Name           string         `json:"name"`
	Description    sql.NullString `json:"description"`
	CronExpression string         `json:"cronExpression"`
	TargetID       int64          `json:"targetId"`
	RetentionDays  int64          `json:"retentionDays"`
	Enabled        bool           `json:"enabled"`
	ID             int64          `json:"id"`
}

func (q *Queries) UpdateBackupSchedule(ctx context.Context, arg *UpdateBackupScheduleParams) (*BackupSchedule, error) {
	row := q.db.QueryRowContext(ctx, UpdateBackupSchedule,
		arg.Name,
		arg.Description,
		arg.CronExpression,
		arg.TargetID,
		arg.RetentionDays,
		arg.Enabled,
		arg.ID,
	)
	var i BackupSchedule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CronExpression,
		&i.TargetID,
		&i.RetentionDays,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastRunAt,
		&i.NextRunAt,
	)
	return &i, err
}

const UpdateBackupScheduleLastRun = `-- name: UpdateBackupScheduleLastRun :one
UPDATE backup_schedules
SET last_run_at = ?,
    next_run_at = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, description, cron_expression, target_id, retention_days, enabled, created_at, updated_at, last_run_at, next_run_at
`

type UpdateBackupScheduleLastRunParams struct {
	LastRunAt sql.NullTime `json:"lastRunAt"`
	NextRunAt sql.NullTime `json:"nextRunAt"`
	ID        int64        `json:"id"`
}

func (q *Queries) UpdateBackupScheduleLastRun(ctx context.Context, arg *UpdateBackupScheduleLastRunParams) (*BackupSchedule, error) {
	row := q.db.QueryRowContext(ctx, UpdateBackupScheduleLastRun, arg.LastRunAt, arg.NextRunAt, arg.ID)
	var i BackupSchedule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CronExpression,
		&i.TargetID,
		&i.RetentionDays,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastRunAt,
		&i.NextRunAt,
	)
	return &i, err
}

const UpdateBackupSize = `-- name: UpdateBackupSize :one
UPDATE backups
SET size_bytes = ?
WHERE id = ?
RETURNING id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent
`

type UpdateBackupSizeParams struct {
	SizeBytes sql.NullInt64 `json:"sizeBytes"`
	ID        int64         `json:"id"`
}

func (q *Queries) UpdateBackupSize(ctx context.Context, arg *UpdateBackupSizeParams) (*Backup, error) {
	row := q.db.QueryRowContext(ctx, UpdateBackupSize, arg.SizeBytes, arg.ID)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.ScheduleID,
		&i.TargetID,
		&i.Status,
		&i.SizeBytes,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.NotificationSent,
	)
	return &i, err
}

const UpdateBackupStatus = `-- name: UpdateBackupStatus :one
UPDATE backups
SET status = ?
WHERE id = ?
RETURNING id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent
`

type UpdateBackupStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateBackupStatus(ctx context.Context, arg *UpdateBackupStatusParams) (*Backup, error) {
	row := q.db.QueryRowContext(ctx, UpdateBackupStatus, arg.Status, arg.ID)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.ScheduleID,
		&i.TargetID,
		&i.Status,
		&i.SizeBytes,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.NotificationSent,
	)
	return &i, err
}

const UpdateBackupTarget = `-- name: UpdateBackupTarget :one
UPDATE backup_targets
SET name = ?,
    type = ?,
    bucket_name = ?,
    region = ?,
    endpoint = ?,
    bucket_path = ?,
    access_key_id = ?,
    secret_key = ?,
    s3_path_style = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, bucket_name, region, endpoint, bucket_path, access_key_id, secret_key, s3_path_style, restic_password, type, created_at, updated_at
`

type UpdateBackupTargetParams struct {
	Name        string         `json:"name"`
	Type        string         `json:"type"`
	BucketName  sql.NullString `json:"bucketName"`
	Region      sql.NullString `json:"region"`
	Endpoint    sql.NullString `json:"endpoint"`
	BucketPath  sql.NullString `json:"bucketPath"`
	AccessKeyID sql.NullString `json:"accessKeyId"`
	SecretKey   sql.NullString `json:"secretKey"`
	S3PathStyle sql.NullBool   `json:"s3PathStyle"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdateBackupTarget(ctx context.Context, arg *UpdateBackupTargetParams) (*BackupTarget, error) {
	row := q.db.QueryRowContext(ctx, UpdateBackupTarget,
		arg.Name,
		arg.Type,
		arg.BucketName,
		arg.Region,
		arg.Endpoint,
		arg.BucketPath,
		arg.AccessKeyID,
		arg.SecretKey,
		arg.S3PathStyle,
		arg.ID,
	)
	var i BackupTarget
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BucketName,
		&i.Region,
		&i.Endpoint,
		&i.BucketPath,
		&i.AccessKeyID,
		&i.SecretKey,
		&i.S3PathStyle,
		&i.ResticPassword,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateDeploymentConfig = `-- name: UpdateDeploymentConfig :one
UPDATE nodes
SET deployment_config = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config, error_message
`

type UpdateDeploymentConfigParams struct {
	DeploymentConfig sql.NullString `json:"deploymentConfig"`
	ID               int64          `json:"id"`
}

func (q *Queries) UpdateDeploymentConfig(ctx context.Context, arg *UpdateDeploymentConfigParams) (*Node, error) {
	row := q.db.QueryRowContext(ctx, UpdateDeploymentConfig, arg.DeploymentConfig, arg.ID)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.NetworkID,
		&i.Config,
		&i.Resources,
		&i.Endpoint,
		&i.PublicEndpoint,
		&i.P2pAddress,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.FabricOrganizationID,
		&i.NodeType,
		&i.NodeConfig,
		&i.DeploymentConfig,
		&i.ErrorMessage,
	)
	return &i, err
}

const UpdateDeploymentMetadata = `-- name: UpdateDeploymentMetadata :exec
UPDATE plugins
SET deployment_metadata = ?
WHERE name = ?
`

type UpdateDeploymentMetadataParams struct {
	DeploymentMetadata interface{} `json:"deploymentMetadata"`
	Name               string      `json:"name"`
}

func (q *Queries) UpdateDeploymentMetadata(ctx context.Context, arg *UpdateDeploymentMetadataParams) error {
	_, err := q.db.ExecContext(ctx, UpdateDeploymentMetadata, arg.DeploymentMetadata, arg.Name)
	return err
}

const UpdateDeploymentStatus = `-- name: UpdateDeploymentStatus :exec
UPDATE plugins
SET deployment_status = ?
WHERE name = ?
`

type UpdateDeploymentStatusParams struct {
	DeploymentStatus sql.NullString `json:"deploymentStatus"`
	Name             string         `json:"name"`
}

func (q *Queries) UpdateDeploymentStatus(ctx context.Context, arg *UpdateDeploymentStatusParams) error {
	_, err := q.db.ExecContext(ctx, UpdateDeploymentStatus, arg.DeploymentStatus, arg.Name)
	return err
}

const UpdateFabricOrganization = `-- name: UpdateFabricOrganization :one
UPDATE fabric_organizations
SET description = ?
WHERE id = ?
RETURNING id, msp_id, description, config, ca_config, sign_key_id, tls_root_key_id, admin_tls_key_id, admin_sign_key_id, client_sign_key_id, provider_id, created_at, created_by, updated_at, crl_key_id, crl_last_update
`

type UpdateFabricOrganizationParams struct {
	Description sql.NullString `json:"description"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdateFabricOrganization(ctx context.Context, arg *UpdateFabricOrganizationParams) (*FabricOrganization, error) {
	row := q.db.QueryRowContext(ctx, UpdateFabricOrganization, arg.Description, arg.ID)
	var i FabricOrganization
	err := row.Scan(
		&i.ID,
		&i.MspID,
		&i.Description,
		&i.Config,
		&i.CaConfig,
		&i.SignKeyID,
		&i.TlsRootKeyID,
		&i.AdminTlsKeyID,
		&i.AdminSignKeyID,
		&i.ClientSignKeyID,
		&i.ProviderID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.CrlKeyID,
		&i.CrlLastUpdate,
	)
	return &i, err
}

const UpdateKey = `-- name: UpdateKey :one
UPDATE keys
SET name = ?,
    description = ?,
    algorithm = ?,
    key_size = ?,
    curve = ?,
    format = ?,
    public_key = ?,
    private_key = ?,
    certificate = ?,
    status = ?,
    expires_at = ?,
    sha256_fingerprint = ?,
    sha1_fingerprint = ?,
    provider_id = ?,
    user_id = ?,
    ethereum_address = ?,
    updated_at = CURRENT_TIMESTAMP,
    signing_key_id = ?
WHERE id = ?
RETURNING id, name, description, algorithm, key_size, curve, format, public_key, private_key, certificate, status, created_at, updated_at, expires_at, last_rotated_at, signing_key_id, sha256_fingerprint, sha1_fingerprint, provider_id, user_id, is_ca, ethereum_address
`

type UpdateKeyParams struct {
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Algorithm         string         `json:"algorithm"`
	KeySize           sql.NullInt64  `json:"keySize"`
	Curve             sql.NullString `json:"curve"`
	Format            string         `json:"format"`
	PublicKey         string         `json:"publicKey"`
	PrivateKey        string         `json:"privateKey"`
	Certificate       sql.NullString `json:"certificate"`
	Status            string         `json:"status"`
	ExpiresAt         sql.NullTime   `json:"expiresAt"`
	Sha256Fingerprint string         `json:"sha256Fingerprint"`
	Sha1Fingerprint   string         `json:"sha1Fingerprint"`
	ProviderID        int64          `json:"providerId"`
	UserID            int64          `json:"userId"`
	EthereumAddress   sql.NullString `json:"ethereumAddress"`
	SigningKeyID      sql.NullInt64  `json:"signingKeyId"`
	ID                int64          `json:"id"`
}

func (q *Queries) UpdateKey(ctx context.Context, arg *UpdateKeyParams) (*Key, error) {
	row := q.db.QueryRowContext(ctx, UpdateKey,
		arg.Name,
		arg.Description,
		arg.Algorithm,
		arg.KeySize,
		arg.Curve,
		arg.Format,
		arg.PublicKey,
		arg.PrivateKey,
		arg.Certificate,
		arg.Status,
		arg.ExpiresAt,
		arg.Sha256Fingerprint,
		arg.Sha1Fingerprint,
		arg.ProviderID,
		arg.UserID,
		arg.EthereumAddress,
		arg.SigningKeyID,
		arg.ID,
	)
	var i Key
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Algorithm,
		&i.KeySize,
		&i.Curve,
		&i.Format,
		&i.PublicKey,
		&i.PrivateKey,
		&i.Certificate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.LastRotatedAt,
		&i.SigningKeyID,
		&i.Sha256Fingerprint,
		&i.Sha1Fingerprint,
		&i.ProviderID,
		&i.UserID,
		&i.IsCa,
		&i.EthereumAddress,
	)
	return &i, err
}

const UpdateKeyProvider = `-- name: UpdateKeyProvider :one
UPDATE key_providers
SET name = ?,
    type = ?,
    is_default = ?,
    config = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, type, is_default, config, created_at, updated_at
`

type UpdateKeyProviderParams struct {
	Name      string `json:"name"`
	Type      string `json:"type"`
	IsDefault int64  `json:"isDefault"`
	Config    string `json:"config"`
	ID        int64  `json:"id"`
}

func (q *Queries) UpdateKeyProvider(ctx context.Context, arg *UpdateKeyProviderParams) (*KeyProvider, error) {
	row := q.db.QueryRowContext(ctx, UpdateKeyProvider,
		arg.Name,
		arg.Type,
		arg.IsDefault,
		arg.Config,
		arg.ID,
	)
	var i KeyProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.IsDefault,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateNetworkCurrentConfigBlock = `-- name: UpdateNetworkCurrentConfigBlock :exec
UPDATE networks
SET current_config_block_b64 = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateNetworkCurrentConfigBlockParams struct {
	CurrentConfigBlockB64 sql.NullString `json:"currentConfigBlockB64"`
	ID                    int64          `json:"id"`
}

func (q *Queries) UpdateNetworkCurrentConfigBlock(ctx context.Context, arg *UpdateNetworkCurrentConfigBlockParams) error {
	_, err := q.db.ExecContext(ctx, UpdateNetworkCurrentConfigBlock, arg.CurrentConfigBlockB64, arg.ID)
	return err
}

const UpdateNetworkGenesisBlock = `-- name: UpdateNetworkGenesisBlock :one
UPDATE networks
SET genesis_block_b64 = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, network_id, platform, status, description, config, deployment_config, exposed_ports, domain, created_at, created_by, updated_at, genesis_block_b64, current_config_block_b64
`

type UpdateNetworkGenesisBlockParams struct {
	GenesisBlockB64 sql.NullString `json:"genesisBlockB64"`
	ID              int64          `json:"id"`
}

func (q *Queries) UpdateNetworkGenesisBlock(ctx context.Context, arg *UpdateNetworkGenesisBlockParams) (*Network, error) {
	row := q.db.QueryRowContext(ctx, UpdateNetworkGenesisBlock, arg.GenesisBlockB64, arg.ID)
	var i Network
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NetworkID,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.Config,
		&i.DeploymentConfig,
		&i.ExposedPorts,
		&i.Domain,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.GenesisBlockB64,
		&i.CurrentConfigBlockB64,
	)
	return &i, err
}

const UpdateNetworkNodeRole = `-- name: UpdateNetworkNodeRole :one
UPDATE network_nodes
SET role = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE network_id = ? AND node_id = ?
RETURNING id, network_id, node_id, role, status, config, created_at, updated_at
`

type UpdateNetworkNodeRoleParams struct {
	Role      string `json:"role"`
	NetworkID int64  `json:"networkId"`
	NodeID    int64  `json:"nodeId"`
}

func (q *Queries) UpdateNetworkNodeRole(ctx context.Context, arg *UpdateNetworkNodeRoleParams) (*NetworkNode, error) {
	row := q.db.QueryRowContext(ctx, UpdateNetworkNodeRole, arg.Role, arg.NetworkID, arg.NodeID)
	var i NetworkNode
	err := row.Scan(
		&i.ID,
		&i.NetworkID,
		&i.NodeID,
		&i.Role,
		&i.Status,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateNetworkNodeStatus = `-- name: UpdateNetworkNodeStatus :one
UPDATE network_nodes
SET status = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE network_id = ? AND node_id = ?
RETURNING id, network_id, node_id, role, status, config, created_at, updated_at
`

type UpdateNetworkNodeStatusParams struct {
	Status    string `json:"status"`
	NetworkID int64  `json:"networkId"`
	NodeID    int64  `json:"nodeId"`
}

func (q *Queries) UpdateNetworkNodeStatus(ctx context.Context, arg *UpdateNetworkNodeStatusParams) (*NetworkNode, error) {
	row := q.db.QueryRowContext(ctx, UpdateNetworkNodeStatus, arg.Status, arg.NetworkID, arg.NodeID)
	var i NetworkNode
	err := row.Scan(
		&i.ID,
		&i.NetworkID,
		&i.NodeID,
		&i.Role,
		&i.Status,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateNetworkStatus = `-- name: UpdateNetworkStatus :exec
UPDATE networks
SET status = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateNetworkStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateNetworkStatus(ctx context.Context, arg *UpdateNetworkStatusParams) error {
	_, err := q.db.ExecContext(ctx, UpdateNetworkStatus, arg.Status, arg.ID)
	return err
}

const UpdateNodeConfig = `-- name: UpdateNodeConfig :one
UPDATE nodes
SET node_config = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config, error_message
`

type UpdateNodeConfigParams struct {
	NodeConfig sql.NullString `json:"nodeConfig"`
	ID         int64          `json:"id"`
}

func (q *Queries) UpdateNodeConfig(ctx context.Context, arg *UpdateNodeConfigParams) (*Node, error) {
	row := q.db.QueryRowContext(ctx, UpdateNodeConfig, arg.NodeConfig, arg.ID)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.NetworkID,
		&i.Config,
		&i.Resources,
		&i.Endpoint,
		&i.PublicEndpoint,
		&i.P2pAddress,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.FabricOrganizationID,
		&i.NodeType,
		&i.NodeConfig,
		&i.DeploymentConfig,
		&i.ErrorMessage,
	)
	return &i, err
}

const UpdateNodeDeploymentConfig = `-- name: UpdateNodeDeploymentConfig :one
UPDATE nodes
SET deployment_config = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config, error_message
`

type UpdateNodeDeploymentConfigParams struct {
	DeploymentConfig sql.NullString `json:"deploymentConfig"`
	ID               int64          `json:"id"`
}

func (q *Queries) UpdateNodeDeploymentConfig(ctx context.Context, arg *UpdateNodeDeploymentConfigParams) (*Node, error) {
	row := q.db.QueryRowContext(ctx, UpdateNodeDeploymentConfig, arg.DeploymentConfig, arg.ID)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.NetworkID,
		&i.Config,
		&i.Resources,
		&i.Endpoint,
		&i.PublicEndpoint,
		&i.P2pAddress,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.FabricOrganizationID,
		&i.NodeType,
		&i.NodeConfig,
		&i.DeploymentConfig,
		&i.ErrorMessage,
	)
	return &i, err
}

const UpdateNodeEndpoint = `-- name: UpdateNodeEndpoint :one
UPDATE nodes
SET endpoint = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config, error_message
`

type UpdateNodeEndpointParams struct {
	Endpoint sql.NullString `json:"endpoint"`
	ID       int64          `json:"id"`
}

func (q *Queries) UpdateNodeEndpoint(ctx context.Context, arg *UpdateNodeEndpointParams) (*Node, error) {
	row := q.db.QueryRowContext(ctx, UpdateNodeEndpoint, arg.Endpoint, arg.ID)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.NetworkID,
		&i.Config,
		&i.Resources,
		&i.Endpoint,
		&i.PublicEndpoint,
		&i.P2pAddress,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.FabricOrganizationID,
		&i.NodeType,
		&i.NodeConfig,
		&i.DeploymentConfig,
		&i.ErrorMessage,
	)
	return &i, err
}

const UpdateNodePublicEndpoint = `-- name: UpdateNodePublicEndpoint :one
UPDATE nodes
SET public_endpoint = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config, error_message
`

type UpdateNodePublicEndpointParams struct {
	PublicEndpoint sql.NullString `json:"publicEndpoint"`
	ID             int64          `json:"id"`
}

func (q *Queries) UpdateNodePublicEndpoint(ctx context.Context, arg *UpdateNodePublicEndpointParams) (*Node, error) {
	row := q.db.QueryRowContext(ctx, UpdateNodePublicEndpoint, arg.PublicEndpoint, arg.ID)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.NetworkID,
		&i.Config,
		&i.Resources,
		&i.Endpoint,
		&i.PublicEndpoint,
		&i.P2pAddress,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.FabricOrganizationID,
		&i.NodeType,
		&i.NodeConfig,
		&i.DeploymentConfig,
		&i.ErrorMessage,
	)
	return &i, err
}

const UpdateNodeStatus = `-- name: UpdateNodeStatus :one
UPDATE nodes
SET status = ?,
    error_message = NULL,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config, error_message
`

type UpdateNodeStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateNodeStatus(ctx context.Context, arg *UpdateNodeStatusParams) (*Node, error) {
	row := q.db.QueryRowContext(ctx, UpdateNodeStatus, arg.Status, arg.ID)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.NetworkID,
		&i.Config,
		&i.Resources,
		&i.Endpoint,
		&i.PublicEndpoint,
		&i.P2pAddress,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.FabricOrganizationID,
		&i.NodeType,
		&i.NodeConfig,
		&i.DeploymentConfig,
		&i.ErrorMessage,
	)
	return &i, err
}

const UpdateNodeStatusWithError = `-- name: UpdateNodeStatusWithError :one
UPDATE nodes
SET status = ?,
    error_message = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config, error_message
`

type UpdateNodeStatusWithErrorParams struct {
	Status       string         `json:"status"`
	ErrorMessage sql.NullString `json:"errorMessage"`
	ID           int64          `json:"id"`
}

func (q *Queries) UpdateNodeStatusWithError(ctx context.Context, arg *UpdateNodeStatusWithErrorParams) (*Node, error) {
	row := q.db.QueryRowContext(ctx, UpdateNodeStatusWithError, arg.Status, arg.ErrorMessage, arg.ID)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.NetworkID,
		&i.Config,
		&i.Resources,
		&i.Endpoint,
		&i.PublicEndpoint,
		&i.P2pAddress,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.FabricOrganizationID,
		&i.NodeType,
		&i.NodeConfig,
		&i.DeploymentConfig,
		&i.ErrorMessage,
	)
	return &i, err
}

const UpdateNotificationProvider = `-- name: UpdateNotificationProvider :one
UPDATE notification_providers
SET type = ?,
    name = ?,
    config = ?,
    is_default = ?,
    notify_node_downtime = ?,
    notify_backup_success = ?,
    notify_backup_failure = ?,
    notify_s3_connection_issue = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, type, config, is_default, is_enabled, created_at, updated_at, notify_node_downtime, notify_backup_success, notify_backup_failure, notify_s3_connection_issue, last_test_at, last_test_status, last_test_message
`

type UpdateNotificationProviderParams struct {
	Type                    string `json:"type"`
	Name                    string `json:"name"`
	Config                  string `json:"config"`
	IsDefault               bool   `json:"isDefault"`
	NotifyNodeDowntime      bool   `json:"notifyNodeDowntime"`
	NotifyBackupSuccess     bool   `json:"notifyBackupSuccess"`
	NotifyBackupFailure     bool   `json:"notifyBackupFailure"`
	NotifyS3ConnectionIssue bool   `json:"notifyS3ConnectionIssue"`
	ID                      int64  `json:"id"`
}

func (q *Queries) UpdateNotificationProvider(ctx context.Context, arg *UpdateNotificationProviderParams) (*NotificationProvider, error) {
	row := q.db.QueryRowContext(ctx, UpdateNotificationProvider,
		arg.Type,
		arg.Name,
		arg.Config,
		arg.IsDefault,
		arg.NotifyNodeDowntime,
		arg.NotifyBackupSuccess,
		arg.NotifyBackupFailure,
		arg.NotifyS3ConnectionIssue,
		arg.ID,
	)
	var i NotificationProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Config,
		&i.IsDefault,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotifyNodeDowntime,
		&i.NotifyBackupSuccess,
		&i.NotifyBackupFailure,
		&i.NotifyS3ConnectionIssue,
		&i.LastTestAt,
		&i.LastTestStatus,
		&i.LastTestMessage,
	)
	return &i, err
}

const UpdateOrganizationCRL = `-- name: UpdateOrganizationCRL :exec
UPDATE fabric_organizations
SET crl_last_update = ?,
    crl_key_id = ?
WHERE id = ?
`

type UpdateOrganizationCRLParams struct {
	CrlLastUpdate sql.NullTime  `json:"crlLastUpdate"`
	CrlKeyID      sql.NullInt64 `json:"crlKeyId"`
	ID            int64         `json:"id"`
}

func (q *Queries) UpdateOrganizationCRL(ctx context.Context, arg *UpdateOrganizationCRLParams) error {
	_, err := q.db.ExecContext(ctx, UpdateOrganizationCRL, arg.CrlLastUpdate, arg.CrlKeyID, arg.ID)
	return err
}

const UpdatePlugin = `-- name: UpdatePlugin :one
UPDATE plugins
SET 
  api_version = ?,
  kind = ?,
  metadata = ?,
  spec = ?,
  updated_at = CURRENT_TIMESTAMP
WHERE name = ?
RETURNING name, api_version, kind, metadata, spec, created_at, updated_at, deployment_metadata, deployment_status
`

type UpdatePluginParams struct {
	ApiVersion string      `json:"apiVersion"`
	Kind       string      `json:"kind"`
	Metadata   interface{} `json:"metadata"`
	Spec       interface{} `json:"spec"`
	Name       string      `json:"name"`
}

func (q *Queries) UpdatePlugin(ctx context.Context, arg *UpdatePluginParams) (*Plugin, error) {
	row := q.db.QueryRowContext(ctx, UpdatePlugin,
		arg.ApiVersion,
		arg.Kind,
		arg.Metadata,
		arg.Spec,
		arg.Name,
	)
	var i Plugin
	err := row.Scan(
		&i.Name,
		&i.ApiVersion,
		&i.Kind,
		&i.Metadata,
		&i.Spec,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeploymentMetadata,
		&i.DeploymentStatus,
	)
	return &i, err
}

const UpdatePrometheusConfig = `-- name: UpdatePrometheusConfig :one
UPDATE prometheus_config
SET prometheus_port = ?,
    data_dir = ?,
    config_dir = ?,
    container_name = ?,
    scrape_interval = ?,
    evaluation_interval = ?,
    deployment_mode = ?,
    docker_image = ?,
    docker_network = ?,
    docker_restart_policy = ?,
    docker_extra_args = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = 1
RETURNING id, prometheus_port, data_dir, config_dir, container_name, scrape_interval, evaluation_interval, deployment_mode, docker_image, docker_network, docker_restart_policy, docker_extra_args, created_at, updated_at
`

type UpdatePrometheusConfigParams struct {
	PrometheusPort      int64          `json:"prometheusPort"`
	DataDir             string         `json:"dataDir"`
	ConfigDir           string         `json:"configDir"`
	ContainerName       string         `json:"containerName"`
	ScrapeInterval      int64          `json:"scrapeInterval"`
	EvaluationInterval  int64          `json:"evaluationInterval"`
	DeploymentMode      string         `json:"deploymentMode"`
	DockerImage         string         `json:"dockerImage"`
	DockerNetwork       sql.NullString `json:"dockerNetwork"`
	DockerRestartPolicy string         `json:"dockerRestartPolicy"`
	DockerExtraArgs     sql.NullString `json:"dockerExtraArgs"`
}

func (q *Queries) UpdatePrometheusConfig(ctx context.Context, arg *UpdatePrometheusConfigParams) (*PrometheusConfig, error) {
	row := q.db.QueryRowContext(ctx, UpdatePrometheusConfig,
		arg.PrometheusPort,
		arg.DataDir,
		arg.ConfigDir,
		arg.ContainerName,
		arg.ScrapeInterval,
		arg.EvaluationInterval,
		arg.DeploymentMode,
		arg.DockerImage,
		arg.DockerNetwork,
		arg.DockerRestartPolicy,
		arg.DockerExtraArgs,
	)
	var i PrometheusConfig
	err := row.Scan(
		&i.ID,
		&i.PrometheusPort,
		&i.DataDir,
		&i.ConfigDir,
		&i.ContainerName,
		&i.ScrapeInterval,
		&i.EvaluationInterval,
		&i.DeploymentMode,
		&i.DockerImage,
		&i.DockerNetwork,
		&i.DockerRestartPolicy,
		&i.DockerExtraArgs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateProviderTestResults = `-- name: UpdateProviderTestResults :one
UPDATE notification_providers
SET last_test_at = ?,
    last_test_status = ?,
    last_test_message = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, type, config, is_default, is_enabled, created_at, updated_at, notify_node_downtime, notify_backup_success, notify_backup_failure, notify_s3_connection_issue, last_test_at, last_test_status, last_test_message
`

type UpdateProviderTestResultsParams struct {
	LastTestAt      sql.NullTime   `json:"lastTestAt"`
	LastTestStatus  sql.NullString `json:"lastTestStatus"`
	LastTestMessage sql.NullString `json:"lastTestMessage"`
	ID              int64          `json:"id"`
}

func (q *Queries) UpdateProviderTestResults(ctx context.Context, arg *UpdateProviderTestResultsParams) (*NotificationProvider, error) {
	row := q.db.QueryRowContext(ctx, UpdateProviderTestResults,
		arg.LastTestAt,
		arg.LastTestStatus,
		arg.LastTestMessage,
		arg.ID,
	)
	var i NotificationProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Config,
		&i.IsDefault,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotifyNodeDowntime,
		&i.NotifyBackupSuccess,
		&i.NotifyBackupFailure,
		&i.NotifyS3ConnectionIssue,
		&i.LastTestAt,
		&i.LastTestStatus,
		&i.LastTestMessage,
	)
	return &i, err
}

const UpdateSetting = `-- name: UpdateSetting :one
UPDATE settings
SET config = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, config, created_at, updated_at
`

type UpdateSettingParams struct {
	Config string `json:"config"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateSetting(ctx context.Context, arg *UpdateSettingParams) (*Setting, error) {
	row := q.db.QueryRowContext(ctx, UpdateSetting, arg.Config, arg.ID)
	var i Setting
	err := row.Scan(
		&i.ID,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateUser = `-- name: UpdateUser :one
UPDATE users
SET username = ?,
    role = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, username, password, name, email, role, provider, provider_id, avatar_url, created_at, last_login_at, updated_at
`

type UpdateUserParams struct {
	Username string         `json:"username"`
	Role     sql.NullString `json:"role"`
	ID       int64          `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg *UpdateUserParams) (*User, error) {
	row := q.db.QueryRowContext(ctx, UpdateUser, arg.Username, arg.Role, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Name,
		&i.Email,
		&i.Role,
		&i.Provider,
		&i.ProviderID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.LastLoginAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateUserLastLogin = `-- name: UpdateUserLastLogin :one
UPDATE users
SET last_login_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, username, password, name, email, role, provider, provider_id, avatar_url, created_at, last_login_at, updated_at
`

func (q *Queries) UpdateUserLastLogin(ctx context.Context, id int64) (*User, error) {
	row := q.db.QueryRowContext(ctx, UpdateUserLastLogin, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Name,
		&i.Email,
		&i.Role,
		&i.Provider,
		&i.ProviderID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.LastLoginAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateUserPassword = `-- name: UpdateUserPassword :one
UPDATE users
SET password = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, username, password, name, email, role, provider, provider_id, avatar_url, created_at, last_login_at, updated_at
`

type UpdateUserPasswordParams struct {
	Password string `json:"password"`
	ID       int64  `json:"id"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg *UpdateUserPasswordParams) (*User, error) {
	row := q.db.QueryRowContext(ctx, UpdateUserPassword, arg.Password, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Name,
		&i.Email,
		&i.Role,
		&i.Provider,
		&i.ProviderID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.LastLoginAt,
		&i.UpdatedAt,
	)
	return &i, err
}
